/*
* Copyright (c) 2019, FusionAuth, All Rights Reserved
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
* either express or implied. See the License for the specific
* language governing permissions and limitations under the License.
*/

import IRESTClient from "./IRESTClient"
import DefaultRESTClientBuilder from "./DefaultRESTClientBuilder";
import IRESTClientBuilder from "./IRESTClientBuilder";
import ClientResponse from "./ClientResponse";

export class FusionAuthClient {

  public clientBuilder: IRESTClientBuilder = new DefaultRESTClientBuilder();

  constructor(public apiKey: string, public host: string) {
  }

  /**
   * Takes an action on a user. The user being actioned is called the "actionee" and the user taking the action is called the
   * "actioner". Both user ids are required. You pass the actionee's user id into the method and the actioner's is put into the
   * request object.
   *
   * @param {string} actioneeUserId The actionee's user id.
   * @param {ActionRequest} request The action request that includes all of the information about the action being taken including
   *    the id of the action, any options and the duration (if applicable).
   * @returns {Observable<ClientResponse<ActionResponse>>}
   */
  actionUser(actioneeUserId: string, request: ActionRequest): Observable<ClientResponse<ActionResponse>> {
    return this.start()
        .withUri('/api/user/action')
        .withUriSegment(actioneeUserId)
        .withJSONBody(request)
        .withMethod("POST")
        .go<ActionResponse>();
  }

  /**
   * Adds a user to an existing family. The family id must be specified.
   *
   * @param {string} familyId The id of the family.
   * @param {FamilyRequest} request The request object that contains all of the information used to determine which user to add to the family.
   * @returns {Observable<ClientResponse<FamilyResponse>>}
   */
  addUserToFamily(familyId: string, request: FamilyRequest): Observable<ClientResponse<FamilyResponse>> {
    return this.start()
        .withUri('/api/user/family')
        .withUriSegment(familyId)
        .withJSONBody(request)
        .withMethod("PUT")
        .go<FamilyResponse>();
  }

  /**
   * Cancels the user action.
   *
   * @param {string} actionId The action id of the action to cancel.
   * @param {ActionRequest} request The action request that contains the information about the cancellation.
   * @returns {Observable<ClientResponse<ActionResponse>>}
   */
  cancelAction(actionId: string, request: ActionRequest): Observable<ClientResponse<ActionResponse>> {
    return this.start()
        .withUri('/api/user/action')
        .withUriSegment(actionId)
        .withJSONBody(request)
        .withMethod("DELETE")
        .go<ActionResponse>();
  }

  /**
   * Changes a user's password using the change password Id. This usually occurs after an email has been sent to the user
   * and they clicked on a link to reset their password.
   *
   * @param {string} changePasswordId The change password Id used to find the user. This value is generated by FusionAuth once the change password workflow has been initiated.
   * @param {ChangePasswordRequest} request The change password request that contains all of the information used to change the password.
   * @returns {Observable<ClientResponse<ChangePasswordResponse>>}
   */
  changePassword(changePasswordId: string, request: ChangePasswordRequest): Observable<ClientResponse<ChangePasswordResponse>> {
    return this.start()
        .withUri('/api/user/change-password')
        .withUriSegment(changePasswordId)
        .withJSONBody(request)
        .withMethod("POST")
        .go<ChangePasswordResponse>();
  }

  /**
   * Changes a user's password using their identity (login id and password). Using a loginId instead of the changePasswordId
   * bypasses the email verification and allows a password to be changed directly without first calling the #forgotPassword
   * method.
   *
   * @param {ChangePasswordRequest} request The change password request that contains all of the information used to change the password.
   * @returns {Observable<ClientResponse<void>>}
   */
  changePasswordByIdentity(request: ChangePasswordRequest): Observable<ClientResponse<void>> {
    return this.start()
        .withUri('/api/user/change-password')
        .withJSONBody(request)
        .withMethod("POST")
        .go<void>();
  }

  /**
   * Adds a comment to the user's account.
   *
   * @param {UserCommentRequest} request The request object that contains all of the information used to create the user comment.
   * @returns {Observable<ClientResponse<void>>}
   */
  commentOnUser(request: UserCommentRequest): Observable<ClientResponse<void>> {
    return this.start()
        .withUri('/api/user/comment')
        .withJSONBody(request)
        .withMethod("POST")
        .go<void>();
  }

  /**
   * Creates an application. You can optionally specify an Id for the application, if not provided one will be generated.
   *
   * @param {string} applicationId (Optional) The Id to use for the application. If not provided a secure random UUID will be generated.
   * @param {ApplicationRequest} request The request object that contains all of the information used to create the application.
   * @returns {Observable<ClientResponse<ApplicationResponse>>}
   */
  createApplication(applicationId: string, request: ApplicationRequest): Observable<ClientResponse<ApplicationResponse>> {
    return this.start()
        .withUri('/api/application')
        .withUriSegment(applicationId)
        .withJSONBody(request)
        .withMethod("POST")
        .go<ApplicationResponse>();
  }

  /**
   * Creates a new role for an application. You must specify the id of the application you are creating the role for.
   * You can optionally specify an Id for the role inside the ApplicationRole object itself, if not provided one will be generated.
   *
   * @param {string} applicationId The Id of the application to create the role on.
   * @param {string} roleId (Optional) The Id of the role. If not provided a secure random UUID will be generated.
   * @param {ApplicationRequest} request The request object that contains all of the information used to create the application role.
   * @returns {Observable<ClientResponse<ApplicationResponse>>}
   */
  createApplicationRole(applicationId: string, roleId: string, request: ApplicationRequest): Observable<ClientResponse<ApplicationResponse>> {
    return this.start()
        .withUri('/api/application')
        .withUriSegment(applicationId)
        .withUriSegment("role")
        .withUriSegment(roleId)
        .withJSONBody(request)
        .withMethod("POST")
        .go<ApplicationResponse>();
  }

  /**
   * Creates an audit log with the message and user name (usually an email). Audit logs should be written anytime you
   * make changes to the FusionAuth database. When using the FusionAuth App web interface, any changes are automatically
   * written to the audit log. However, if you are accessing the API, you must write the audit logs yourself.
   *
   * @param {AuditLogRequest} request The request object that contains all of the information used to create the audit log entry.
   * @returns {Observable<ClientResponse<AuditLogResponse>>}
   */
  createAuditLog(request: AuditLogRequest): Observable<ClientResponse<AuditLogResponse>> {
    return this.start()
        .withUri('/api/system/audit-log')
        .withJSONBody(request)
        .withMethod("POST")
        .go<AuditLogResponse>();
  }

  /**
   * Creates a user consent type. You can optionally specify an Id for the consent type, if not provided one will be generated.
   *
   * @param {string} consentId (Optional) The Id for the consent. If not provided a secure random UUID will be generated.
   * @param {ConsentRequest} request The request object that contains all of the information used to create the consent.
   * @returns {Observable<ClientResponse<ConsentResponse>>}
   */
  createConsent(consentId: string, request: ConsentRequest): Observable<ClientResponse<ConsentResponse>> {
    return this.start()
        .withUri('/api/consent')
        .withUriSegment(consentId)
        .withJSONBody(request)
        .withMethod("POST")
        .go<ConsentResponse>();
  }

  /**
   * Creates an email template. You can optionally specify an Id for the template, if not provided one will be generated.
   *
   * @param {string} emailTemplateId (Optional) The Id for the template. If not provided a secure random UUID will be generated.
   * @param {EmailTemplateRequest} request The request object that contains all of the information used to create the email template.
   * @returns {Observable<ClientResponse<EmailTemplateResponse>>}
   */
  createEmailTemplate(emailTemplateId: string, request: EmailTemplateRequest): Observable<ClientResponse<EmailTemplateResponse>> {
    return this.start()
        .withUri('/api/email/template')
        .withUriSegment(emailTemplateId)
        .withJSONBody(request)
        .withMethod("POST")
        .go<EmailTemplateResponse>();
  }

  /**
   * Creates a family with the user id in the request as the owner and sole member of the family. You can optionally specify an id for the
   * family, if not provided one will be generated.
   *
   * @param {string} familyId (Optional) The id for the family. If not provided a secure random UUID will be generated.
   * @param {FamilyRequest} request The request object that contains all of the information used to create the family.
   * @returns {Observable<ClientResponse<FamilyResponse>>}
   */
  createFamily(familyId: string, request: FamilyRequest): Observable<ClientResponse<FamilyResponse>> {
    return this.start()
        .withUri('/api/user/family')
        .withUriSegment(familyId)
        .withJSONBody(request)
        .withMethod("POST")
        .go<FamilyResponse>();
  }

  /**
   * Creates a group. You can optionally specify an Id for the group, if not provided one will be generated.
   *
   * @param {string} groupId (Optional) The Id for the group. If not provided a secure random UUID will be generated.
   * @param {GroupRequest} request The request object that contains all of the information used to create the group.
   * @returns {Observable<ClientResponse<GroupResponse>>}
   */
  createGroup(groupId: string, request: GroupRequest): Observable<ClientResponse<GroupResponse>> {
    return this.start()
        .withUri('/api/group')
        .withUriSegment(groupId)
        .withJSONBody(request)
        .withMethod("POST")
        .go<GroupResponse>();
  }

  /**
   * Creates a member in a group.
   *
   * @param {MemberRequest} request The request object that contains all of the information used to create the group member(s).
   * @returns {Observable<ClientResponse<MemberResponse>>}
   */
  createGroupMembers(request: MemberRequest): Observable<ClientResponse<MemberResponse>> {
    return this.start()
        .withUri('/api/group/member')
        .withJSONBody(request)
        .withMethod("POST")
        .go<MemberResponse>();
  }

  /**
   * Creates an identity provider. You can optionally specify an Id for the identity provider, if not provided one will be generated.
   *
   * @param {string} identityProviderId (Optional) The Id of the identity provider. If not provided a secure random UUID will be generated.
   * @param {IdentityProviderRequest} request The request object that contains all of the information used to create the identity provider.
   * @returns {Observable<ClientResponse<IdentityProviderResponse>>}
   */
  createIdentityProvider(identityProviderId: string, request: IdentityProviderRequest): Observable<ClientResponse<IdentityProviderResponse>> {
    return this.start()
        .withUri('/api/identity-provider')
        .withUriSegment(identityProviderId)
        .withJSONBody(request)
        .withMethod("POST")
        .go<IdentityProviderResponse>();
  }

  /**
   * Creates a Lambda. You can optionally specify an Id for the lambda, if not provided one will be generated.
   *
   * @param {string} lambdaId (Optional) The Id for the lambda. If not provided a secure random UUID will be generated.
   * @param {LambdaRequest} request The request object that contains all of the information used to create the lambda.
   * @returns {Observable<ClientResponse<LambdaResponse>>}
   */
  createLambda(lambdaId: string, request: LambdaRequest): Observable<ClientResponse<LambdaResponse>> {
    return this.start()
        .withUri('/api/lambda')
        .withUriSegment(lambdaId)
        .withJSONBody(request)
        .withMethod("POST")
        .go<LambdaResponse>();
  }

  /**
   * Creates a tenant. You can optionally specify an Id for the tenant, if not provided one will be generated.
   *
   * @param {string} tenantId (Optional) The Id for the tenant. If not provided a secure random UUID will be generated.
   * @param {TenantRequest} request The request object that contains all of the information used to create the tenant.
   * @returns {Observable<ClientResponse<TenantResponse>>}
   */
  createTenant(tenantId: string, request: TenantRequest): Observable<ClientResponse<TenantResponse>> {
    return this.start()
        .withUri('/api/tenant')
        .withUriSegment(tenantId)
        .withJSONBody(request)
        .withMethod("POST")
        .go<TenantResponse>();
  }

  /**
   * Creates a user. You can optionally specify an Id for the user, if not provided one will be generated.
   *
   * @param {string} userId (Optional) The Id for the user. If not provided a secure random UUID will be generated.
   * @param {UserRequest} request The request object that contains all of the information used to create the user.
   * @returns {Observable<ClientResponse<UserResponse>>}
   */
  createUser(userId: string, request: UserRequest): Observable<ClientResponse<UserResponse>> {
    return this.start()
        .withUri('/api/user')
        .withUriSegment(userId)
        .withJSONBody(request)
        .withMethod("POST")
        .go<UserResponse>();
  }

  /**
   * Creates a user action. This action cannot be taken on a user until this call successfully returns. Anytime after
   * that the user action can be applied to any user.
   *
   * @param {string} userActionId (Optional) The Id for the user action. If not provided a secure random UUID will be generated.
   * @param {UserActionRequest} request The request object that contains all of the information used to create the user action.
   * @returns {Observable<ClientResponse<UserActionResponse>>}
   */
  createUserAction(userActionId: string, request: UserActionRequest): Observable<ClientResponse<UserActionResponse>> {
    return this.start()
        .withUri('/api/user-action')
        .withUriSegment(userActionId)
        .withJSONBody(request)
        .withMethod("POST")
        .go<UserActionResponse>();
  }

  /**
   * Creates a user reason. This user action reason cannot be used when actioning a user until this call completes
   * successfully. Anytime after that the user action reason can be used.
   *
   * @param {string} userActionReasonId (Optional) The Id for the user action reason. If not provided a secure random UUID will be generated.
   * @param {UserActionReasonRequest} request The request object that contains all of the information used to create the user action reason.
   * @returns {Observable<ClientResponse<UserActionReasonResponse>>}
   */
  createUserActionReason(userActionReasonId: string, request: UserActionReasonRequest): Observable<ClientResponse<UserActionReasonResponse>> {
    return this.start()
        .withUri('/api/user-action-reason')
        .withUriSegment(userActionReasonId)
        .withJSONBody(request)
        .withMethod("POST")
        .go<UserActionReasonResponse>();
  }

  /**
   * Creates a single User consent.
   *
   * @param {string} userConsentId (Optional) The Id for the User consent. If not provided a secure random UUID will be generated.
   * @param {UserConsentRequest} request The request that contains the user consent information.
   * @returns {Observable<ClientResponse<UserConsentResponse>>}
   */
  createUserConsent(userConsentId: string, request: UserConsentRequest): Observable<ClientResponse<UserConsentResponse>> {
    return this.start()
        .withUri('/api/user/consent')
        .withUriSegment(userConsentId)
        .withJSONBody(request)
        .withMethod("POST")
        .go<UserConsentResponse>();
  }

  /**
   * Creates a webhook. You can optionally specify an Id for the webhook, if not provided one will be generated.
   *
   * @param {string} webhookId (Optional) The Id for the webhook. If not provided a secure random UUID will be generated.
   * @param {WebhookRequest} request The request object that contains all of the information used to create the webhook.
   * @returns {Observable<ClientResponse<WebhookResponse>>}
   */
  createWebhook(webhookId: string, request: WebhookRequest): Observable<ClientResponse<WebhookResponse>> {
    return this.start()
        .withUri('/api/webhook')
        .withUriSegment(webhookId)
        .withJSONBody(request)
        .withMethod("POST")
        .go<WebhookResponse>();
  }

  /**
   * Deactivates the application with the given Id.
   *
   * @param {string} applicationId The Id of the application to deactivate.
   * @returns {Observable<ClientResponse<void>>}
   */
  deactivateApplication(applicationId: string): Observable<ClientResponse<void>> {
    return this.start()
        .withUri('/api/application')
        .withUriSegment(applicationId)
        .withMethod("DELETE")
        .go<void>();
  }

  /**
   * Deactivates the user with the given Id.
   *
   * @param {string} userId The Id of the user to deactivate.
   * @returns {Observable<ClientResponse<void>>}
   */
  deactivateUser(userId: string): Observable<ClientResponse<void>> {
    return this.start()
        .withUri('/api/user')
        .withUriSegment(userId)
        .withMethod("DELETE")
        .go<void>();
  }

  /**
   * Deactivates the user action with the given Id.
   *
   * @param {string} userActionId The Id of the user action to deactivate.
   * @returns {Observable<ClientResponse<void>>}
   */
  deactivateUserAction(userActionId: string): Observable<ClientResponse<void>> {
    return this.start()
        .withUri('/api/user-action')
        .withUriSegment(userActionId)
        .withMethod("DELETE")
        .go<void>();
  }

  /**
   * Deactivates the users with the given ids.
   *
   * @param {Array<string>} userIds The ids of the users to deactivate.
   * @returns {Observable<ClientResponse<void>>}
   */
  deactivateUsers(userIds: Array<string>): Observable<ClientResponse<void>> {
    return this.start()
        .withUri('/api/user/bulk')
        .withParameter('userId', userIds)
        .withMethod("DELETE")
        .go<void>();
  }

  /**
   * Hard deletes an application. This is a dangerous operation and should not be used in most circumstances. This will
   * delete the application, any registrations for that application, metrics and reports for the application, all the
   * roles for the application, and any other data associated with the application. This operation could take a very
   * long time, depending on the amount of data in your database.
   *
   * @param {string} applicationId The Id of the application to delete.
   * @returns {Observable<ClientResponse<void>>}
   */
  deleteApplication(applicationId: string): Observable<ClientResponse<void>> {
    return this.start()
        .withUri('/api/application')
        .withUriSegment(applicationId)
        .withParameter('hardDelete', true)
        .withMethod("DELETE")
        .go<void>();
  }

  /**
   * Hard deletes an application role. This is a dangerous operation and should not be used in most circumstances. This
   * permanently removes the given role from all users that had it.
   *
   * @param {string} applicationId The Id of the application to deactivate.
   * @param {string} roleId The Id of the role to delete.
   * @returns {Observable<ClientResponse<void>>}
   */
  deleteApplicationRole(applicationId: string, roleId: string): Observable<ClientResponse<void>> {
    return this.start()
        .withUri('/api/application')
        .withUriSegment(applicationId)
        .withUriSegment("role")
        .withUriSegment(roleId)
        .withMethod("DELETE")
        .go<void>();
  }

  /**
   * Deletes the consent for the given Id.
   *
   * @param {string} consentId The Id of the consent to delete.
   * @returns {Observable<ClientResponse<void>>}
   */
  deleteConsent(consentId: string): Observable<ClientResponse<void>> {
    return this.start()
        .withUri('/api/consent')
        .withUriSegment(consentId)
        .withMethod("DELETE")
        .go<void>();
  }

  /**
   * Deletes the email template for the given Id.
   *
   * @param {string} emailTemplateId The Id of the email template to delete.
   * @returns {Observable<ClientResponse<void>>}
   */
  deleteEmailTemplate(emailTemplateId: string): Observable<ClientResponse<void>> {
    return this.start()
        .withUri('/api/email/template')
        .withUriSegment(emailTemplateId)
        .withMethod("DELETE")
        .go<void>();
  }

  /**
   * Deletes the group for the given Id.
   *
   * @param {string} groupId The Id of the group to delete.
   * @returns {Observable<ClientResponse<void>>}
   */
  deleteGroup(groupId: string): Observable<ClientResponse<void>> {
    return this.start()
        .withUri('/api/group')
        .withUriSegment(groupId)
        .withMethod("DELETE")
        .go<void>();
  }

  /**
   * Removes users as members of a group.
   *
   * @param {MemberDeleteRequest} request The member request that contains all of the information used to remove members to the group.
   * @returns {Observable<ClientResponse<void>>}
   */
  deleteGroupMembers(request: MemberDeleteRequest): Observable<ClientResponse<void>> {
    return this.start()
        .withUri('/api/group/member')
        .withJSONBody(request)
        .withMethod("DELETE")
        .go<void>();
  }

  /**
   * Deletes the identity provider for the given Id.
   *
   * @param {string} identityProviderId The Id of the identity provider to delete.
   * @returns {Observable<ClientResponse<void>>}
   */
  deleteIdentityProvider(identityProviderId: string): Observable<ClientResponse<void>> {
    return this.start()
        .withUri('/api/identity-provider')
        .withUriSegment(identityProviderId)
        .withMethod("DELETE")
        .go<void>();
  }

  /**
   * Deletes the key for the given Id.
   *
   * @param {string} keyOd The Id of the key to delete.
   * @returns {Observable<ClientResponse<void>>}
   */
  deleteKey(keyOd: string): Observable<ClientResponse<void>> {
    return this.start()
        .withUri('/api/key')
        .withUriSegment(keyOd)
        .withMethod("DELETE")
        .go<void>();
  }

  /**
   * Deletes the lambda for the given Id.
   *
   * @param {string} lambdaId The Id of the lambda to delete.
   * @returns {Observable<ClientResponse<void>>}
   */
  deleteLambda(lambdaId: string): Observable<ClientResponse<void>> {
    return this.start()
        .withUri('/api/lambda')
        .withUriSegment(lambdaId)
        .withMethod("DELETE")
        .go<void>();
  }

  /**
   * Deletes the user registration for the given user and application.
   *
   * @param {string} userId The Id of the user whose registration is being deleted.
   * @param {string} applicationId The Id of the application to remove the registration for.
   * @returns {Observable<ClientResponse<void>>}
   */
  deleteRegistration(userId: string, applicationId: string): Observable<ClientResponse<void>> {
    return this.start()
        .withUri('/api/user/registration')
        .withUriSegment(userId)
        .withUriSegment(applicationId)
        .withMethod("DELETE")
        .go<void>();
  }

  /**
   * Deletes the tenant for the given Id.
   *
   * @param {string} tenantId The Id of the tenant to delete.
   * @returns {Observable<ClientResponse<void>>}
   */
  deleteTenant(tenantId: string): Observable<ClientResponse<void>> {
    return this.start()
        .withUri('/api/tenant')
        .withUriSegment(tenantId)
        .withMethod("DELETE")
        .go<void>();
  }

  /**
   * Deletes the user for the given Id. This permanently deletes all information, metrics, reports and data associated
   * with the user.
   *
   * @param {string} userId The Id of the user to delete.
   * @returns {Observable<ClientResponse<void>>}
   */
  deleteUser(userId: string): Observable<ClientResponse<void>> {
    return this.start()
        .withUri('/api/user')
        .withUriSegment(userId)
        .withParameter('hardDelete', true)
        .withMethod("DELETE")
        .go<void>();
  }

  /**
   * Deletes the user action for the given Id. This permanently deletes the user action and also any history and logs of
   * the action being applied to any users.
   *
   * @param {string} userActionId The Id of the user action to delete.
   * @returns {Observable<ClientResponse<void>>}
   */
  deleteUserAction(userActionId: string): Observable<ClientResponse<void>> {
    return this.start()
        .withUri('/api/user-action')
        .withUriSegment(userActionId)
        .withParameter('hardDelete', true)
        .withMethod("DELETE")
        .go<void>();
  }

  /**
   * Deletes the user action reason for the given Id.
   *
   * @param {string} userActionReasonId The Id of the user action reason to delete.
   * @returns {Observable<ClientResponse<void>>}
   */
  deleteUserActionReason(userActionReasonId: string): Observable<ClientResponse<void>> {
    return this.start()
        .withUri('/api/user-action-reason')
        .withUriSegment(userActionReasonId)
        .withMethod("DELETE")
        .go<void>();
  }

  /**
   * Deletes the users with the given ids.
   *
   * @param {UserDeleteRequest} request The ids of the users to delete.
   * @returns {Observable<ClientResponse<void>>}
   */
  deleteUsers(request: UserDeleteRequest): Observable<ClientResponse<void>> {
    return this.start()
        .withUri('/api/user/bulk')
        .withJSONBody(request)
        .withMethod("DELETE")
        .go<void>();
  }

  /**
   * Deletes the webhook for the given Id.
   *
   * @param {string} webhookId The Id of the webhook to delete.
   * @returns {Observable<ClientResponse<void>>}
   */
  deleteWebhook(webhookId: string): Observable<ClientResponse<void>> {
    return this.start()
        .withUri('/api/webhook')
        .withUriSegment(webhookId)
        .withMethod("DELETE")
        .go<void>();
  }

  /**
   * Disable Two Factor authentication for a user.
   *
   * @param {string} userId The Id of the User for which you're disabling Two Factor authentication.
   * @param {string} code The Two Factor code used verify the the caller knows the Two Factor secret.
   * @returns {Observable<ClientResponse<void>>}
   */
  disableTwoFactor(userId: string, code: string): Observable<ClientResponse<void>> {
    return this.start()
        .withUri('/api/user/two-factor')
        .withParameter('userId', userId)
        .withParameter('code', code)
        .withMethod("DELETE")
        .go<void>();
  }

  /**
   * Enable Two Factor authentication for a user.
   *
   * @param {string} userId The Id of the user to enable Two Factor authentication.
   * @param {TwoFactorRequest} request The two factor enable request information.
   * @returns {Observable<ClientResponse<void>>}
   */
  enableTwoFactor(userId: string, request: TwoFactorRequest): Observable<ClientResponse<void>> {
    return this.start()
        .withUri('/api/user/two-factor')
        .withUriSegment(userId)
        .withJSONBody(request)
        .withMethod("POST")
        .go<void>();
  }

  /**
   * Exchange a refresh token for a new JWT.
   *
   * @param {RefreshRequest} request The refresh request.
   * @returns {Observable<ClientResponse<RefreshResponse>>}
   */
  exchangeRefreshTokenForJWT(request: RefreshRequest): Observable<ClientResponse<RefreshResponse>> {
    return this.start()
        .withUri('/api/jwt/refresh')
        .withJSONBody(request)
        .withMethod("POST")
        .go<RefreshResponse>();
  }

  /**
   * Begins the forgot password sequence, which kicks off an email to the user so that they can reset their password.
   *
   * @param {ForgotPasswordRequest} request The request that contains the information about the user so that they can be emailed.
   * @returns {Observable<ClientResponse<ForgotPasswordResponse>>}
   */
  forgotPassword(request: ForgotPasswordRequest): Observable<ClientResponse<ForgotPasswordResponse>> {
    return this.start()
        .withUri('/api/user/forgot-password')
        .withJSONBody(request)
        .withMethod("POST")
        .go<ForgotPasswordResponse>();
  }

  /**
   * Generate a new Email Verification Id to be used with the Verify Email API. This API will not attempt to send an
   * email to the User. This API may be used to collect the verificationId for use with a third party system.
   *
   * @param {string} email The email address of the user that needs a new verification email.
   * @returns {Observable<ClientResponse<VerifyEmailResponse>>}
   */
  generateEmailVerificationId(email: string): Observable<ClientResponse<VerifyEmailResponse>> {
    return this.start()
        .withUri('/api/user/verify-email')
        .withParameter('email', email)
        .withParameter('sendVerifyPasswordEmail', false)
        .withMethod("PUT")
        .go<VerifyEmailResponse>();
  }

  /**
   * Generate a new RSA or EC key pair or an HMAC secret.
   *
   * @param {string} keyId (Optional) The Id for the key. If not provided a secure random UUID will be generated.
   * @param {KeyRequest} request The request object that contains all of the information used to create the key.
   * @returns {Observable<ClientResponse<KeyResponse>>}
   */
  generateKey(keyId: string, request: KeyRequest): Observable<ClientResponse<KeyResponse>> {
    return this.start()
        .withUri('/api/key/generate')
        .withUriSegment(keyId)
        .withJSONBody(request)
        .withMethod("POST")
        .go<KeyResponse>();
  }

  /**
   * Generate a new Application Registration Verification Id to be used with the Verify Registration API. This API will not attempt to send an
   * email to the User. This API may be used to collect the verificationId for use with a third party system.
   *
   * @param {string} email The email address of the user that needs a new verification email.
   * @param {string} applicationId The Id of the application to be verified.
   * @returns {Observable<ClientResponse<VerifyRegistrationResponse>>}
   */
  generateRegistrationVerificationId(email: string, applicationId: string): Observable<ClientResponse<VerifyRegistrationResponse>> {
    return this.start()
        .withUri('/api/user/verify-registration')
        .withParameter('email', email)
        .withParameter('sendVerifyPasswordEmail', false)
        .withParameter('applicationId', applicationId)
        .withMethod("PUT")
        .go<VerifyRegistrationResponse>();
  }

  /**
   * Generate a Two Factor secret that can be used to enable Two Factor authentication for a User. The response will contain
   * both the secret and a Base32 encoded form of the secret which can be shown to a User when using a 2 Step Authentication
   * application such as Google Authenticator.
   *
   * @returns {Observable<ClientResponse<SecretResponse>>}
   */
  generateTwoFactorSecret(): Observable<ClientResponse<SecretResponse>> {
    return this.start()
        .withUri('/api/two-factor/secret')
        .withMethod("GET")
        .go<SecretResponse>();
  }

  /**
   * Generate a Two Factor secret that can be used to enable Two Factor authentication for a User. The response will contain
   * both the secret and a Base32 encoded form of the secret which can be shown to a User when using a 2 Step Authentication
   * application such as Google Authenticator.
   *
   * @param {string} encodedJWT The encoded JWT (access token).
   * @returns {Observable<ClientResponse<SecretResponse>>}
   */
  generateTwoFactorSecretUsingJWT(encodedJWT: string): Observable<ClientResponse<SecretResponse>> {
    return this.start()
        .withUri('/api/two-factor/secret')
        .withAuthorization('JWT ' + encodedJWT)
        .withMethod("GET")
        .go<SecretResponse>();
  }

  /**
   * Handles login via third-parties including Social login, external OAuth and OpenID Connect, and other
   * login systems.
   *
   * @param {IdentityProviderLoginRequest} request The third-party login request that contains information from the third-party login
   *    providers that FusionAuth uses to reconcile the user's account.
   * @returns {Observable<ClientResponse<LoginResponse>>}
   */
  identityProviderLogin(request: IdentityProviderLoginRequest): Observable<ClientResponse<LoginResponse>> {
    return this.start()
        .withUri('/api/identity-provider/login')
        .withJSONBody(request)
        .withMethod("POST")
        .go<LoginResponse>();
  }

  /**
   * Import an existing RSA or EC key pair or an HMAC secret.
   *
   * @param {string} keyId (Optional) The Id for the key. If not provided a secure random UUID will be generated.
   * @param {KeyRequest} request The request object that contains all of the information used to create the key.
   * @returns {Observable<ClientResponse<KeyResponse>>}
   */
  importKey(keyId: string, request: KeyRequest): Observable<ClientResponse<KeyResponse>> {
    return this.start()
        .withUri('/api/key/import')
        .withUriSegment(keyId)
        .withJSONBody(request)
        .withMethod("POST")
        .go<KeyResponse>();
  }

  /**
   * Bulk imports multiple users. This does some validation, but then tries to run batch inserts of users. This reduces
   * latency when inserting lots of users. Therefore, the error response might contain some information about failures,
   * but it will likely be pretty generic.
   *
   * @param {ImportRequest} request The request that contains all of the information about all of the users to import.
   * @returns {Observable<ClientResponse<void>>}
   */
  importUsers(request: ImportRequest): Observable<ClientResponse<void>> {
    return this.start()
        .withUri('/api/user/import')
        .withJSONBody(request)
        .withMethod("POST")
        .go<void>();
  }

  /**
   * Issue a new access token (JWT) for the requested Application after ensuring the provided JWT is valid. A valid
   * access token is properly signed and not expired.
   * <p>
   * This API may be used in an SSO configuration to issue new tokens for another application after the user has
   * obtained a valid token from authentication.
   *
   * @param {string} applicationId The Application Id for which you are requesting a new access token be issued.
   * @param {string} encodedJWT The encoded JWT (access token).
   * @returns {Observable<ClientResponse<IssueResponse>>}
   */
  issueJWT(applicationId: string, encodedJWT: string): Observable<ClientResponse<IssueResponse>> {
    return this.start()
        .withUri('/api/jwt/issue')
        .withAuthorization('JWT ' + encodedJWT)
        .withParameter('applicationId', applicationId)
        .withMethod("GET")
        .go<IssueResponse>();
  }

  /**
   * Logs a user in.
   *
   * @param {LoginRequest} request The login request that contains the user credentials used to log them in.
   * @returns {Observable<ClientResponse<LoginResponse>>}
   */
  login(request: LoginRequest): Observable<ClientResponse<LoginResponse>> {
    return this.start()
        .withUri('/api/login')
        .withJSONBody(request)
        .withMethod("POST")
        .go<LoginResponse>();
  }

  /**
   * Sends a ping to FusionAuth indicating that the user was automatically logged into an application. When using
   * FusionAuth's SSO or your own, you should call this if the user is already logged in centrally, but accesses an
   * application where they no longer have a session. This helps correctly track login counts, times and helps with
   * reporting.
   *
   * @param {string} userId The Id of the user that was logged in.
   * @param {string} applicationId The Id of the application that they logged into.
   * @param {string} callerIPAddress (Optional) The IP address of the end-user that is logging in. If a null value is provided
   *    the IP address will be that of the client or last proxy that sent the request.
   * @returns {Observable<ClientResponse<void>>}
   */
  loginPing(userId: string, applicationId: string, callerIPAddress: string): Observable<ClientResponse<void>> {
    return this.start()
        .withUri('/api/login')
        .withUriSegment(userId)
        .withUriSegment(applicationId)
        .withParameter('ipAddress', callerIPAddress)
        .withMethod("PUT")
        .go<void>();
  }

  /**
   * The Logout API is intended to be used to remove the refresh token and access token cookies if they exist on the
   * client and revoke the refresh token stored. This API does nothing if the request does not contain an access
   * token or refresh token cookies.
   *
   * @param {boolean} global When this value is set to true all of the refresh tokens issued to the owner of the
   *    provided token will be revoked.
   * @param {string} refreshToken (Optional) The refresh_token as a request parameter instead of coming in via a cookie.
   *    If provided this takes precedence over the cookie.
   * @returns {Observable<ClientResponse<void>>}
   */
  logout(global: boolean, refreshToken: string): Observable<ClientResponse<void>> {
    return this.start()
        .withHeader('Content-Type', 'text/plain')
        .withUri('/api/logout')
        .withParameter('global', global)
        .withParameter('refreshToken', refreshToken)
        .withMethod("POST")
        .go<void>();
  }

  /**
   * Retrieves the identity provider for the given domain. A 200 response code indicates the domain is managed
   * by a registered identity provider. A 404 indicates the domain is not managed.
   *
   * @param {string} domain The domain or email address to lookup.
   * @returns {Observable<ClientResponse<LookupResponse>>}
   */
  lookupIdentityProvider(domain: string): Observable<ClientResponse<LookupResponse>> {
    return this.start()
        .withUri('/api/identity-provider/lookup')
        .withParameter('domain', domain)
        .withMethod("GET")
        .go<LookupResponse>();
  }

  /**
   * Modifies a temporal user action by changing the expiration of the action and optionally adding a comment to the
   * action.
   *
   * @param {string} actionId The Id of the action to modify. This is technically the user action log id.
   * @param {ActionRequest} request The request that contains all of the information about the modification.
   * @returns {Observable<ClientResponse<ActionResponse>>}
   */
  modifyAction(actionId: string, request: ActionRequest): Observable<ClientResponse<ActionResponse>> {
    return this.start()
        .withUri('/api/user/action')
        .withUriSegment(actionId)
        .withJSONBody(request)
        .withMethod("PUT")
        .go<ActionResponse>();
  }

  /**
   * Complete a login request using a passwordless code
   *
   * @param {PasswordlessLoginRequest} request The passwordless login request that contains all of the information used to complete login.
   * @returns {Observable<ClientResponse<LoginResponse>>}
   */
  passwordlessLogin(request: PasswordlessLoginRequest): Observable<ClientResponse<LoginResponse>> {
    return this.start()
        .withUri('/api/passwordless/login')
        .withJSONBody(request)
        .withMethod("POST")
        .go<LoginResponse>();
  }

  /**
   * Reactivates the application with the given Id.
   *
   * @param {string} applicationId The Id of the application to reactivate.
   * @returns {Observable<ClientResponse<ApplicationResponse>>}
   */
  reactivateApplication(applicationId: string): Observable<ClientResponse<ApplicationResponse>> {
    return this.start()
        .withUri('/api/application')
        .withUriSegment(applicationId)
        .withParameter('reactivate', true)
        .withMethod("PUT")
        .go<ApplicationResponse>();
  }

  /**
   * Reactivates the user with the given Id.
   *
   * @param {string} userId The Id of the user to reactivate.
   * @returns {Observable<ClientResponse<UserResponse>>}
   */
  reactivateUser(userId: string): Observable<ClientResponse<UserResponse>> {
    return this.start()
        .withUri('/api/user')
        .withUriSegment(userId)
        .withParameter('reactivate', true)
        .withMethod("PUT")
        .go<UserResponse>();
  }

  /**
   * Reactivates the user action with the given Id.
   *
   * @param {string} userActionId The Id of the user action to reactivate.
   * @returns {Observable<ClientResponse<UserActionResponse>>}
   */
  reactivateUserAction(userActionId: string): Observable<ClientResponse<UserActionResponse>> {
    return this.start()
        .withUri('/api/user-action')
        .withUriSegment(userActionId)
        .withParameter('reactivate', true)
        .withMethod("PUT")
        .go<UserActionResponse>();
  }

  /**
   * Reconcile a User to FusionAuth using JWT issued from another Identity Provider.
   *
   * @param {IdentityProviderLoginRequest} request The reconcile request that contains the data to reconcile the User.
   * @returns {Observable<ClientResponse<LoginResponse>>}
   */
  reconcileJWT(request: IdentityProviderLoginRequest): Observable<ClientResponse<LoginResponse>> {
    return this.start()
        .withUri('/api/jwt/reconcile')
        .withJSONBody(request)
        .withMethod("POST")
        .go<LoginResponse>();
  }

  /**
   * Registers a user for an application. If you provide the User and the UserRegistration object on this request, it
   * will create the user as well as register them for the application. This is called a Full Registration. However, if
   * you only provide the UserRegistration object, then the user must already exist and they will be registered for the
   * application. The user id can also be provided and it will either be used to look up an existing user or it will be
   * used for the newly created User.
   *
   * @param {string} userId (Optional) The Id of the user being registered for the application and optionally created.
   * @param {RegistrationRequest} request The request that optionally contains the User and must contain the UserRegistration.
   * @returns {Observable<ClientResponse<RegistrationResponse>>}
   */
  register(userId: string, request: RegistrationRequest): Observable<ClientResponse<RegistrationResponse>> {
    return this.start()
        .withUri('/api/user/registration')
        .withUriSegment(userId)
        .withJSONBody(request)
        .withMethod("POST")
        .go<RegistrationResponse>();
  }

  /**
   * Removes a user from the family with the given id.
   *
   * @param {string} familyId The id of the family to remove the user from.
   * @param {string} userId The id of the user to remove from the family.
   * @returns {Observable<ClientResponse<void>>}
   */
  removeUserFromFamily(familyId: string, userId: string): Observable<ClientResponse<void>> {
    return this.start()
        .withUri('/api/user/family')
        .withUriSegment(familyId)
        .withUriSegment(userId)
        .withMethod("DELETE")
        .go<void>();
  }

  /**
   * Re-sends the verification email to the user.
   *
   * @param {string} email The email address of the user that needs a new verification email.
   * @returns {Observable<ClientResponse<VerifyEmailResponse>>}
   */
  resendEmailVerification(email: string): Observable<ClientResponse<VerifyEmailResponse>> {
    return this.start()
        .withUri('/api/user/verify-email')
        .withParameter('email', email)
        .withMethod("PUT")
        .go<VerifyEmailResponse>();
  }

  /**
   * Re-sends the application registration verification email to the user.
   *
   * @param {string} email The email address of the user that needs a new verification email.
   * @param {string} applicationId The Id of the application to be verified.
   * @returns {Observable<ClientResponse<VerifyRegistrationResponse>>}
   */
  resendRegistrationVerification(email: string, applicationId: string): Observable<ClientResponse<VerifyRegistrationResponse>> {
    return this.start()
        .withUri('/api/user/verify-registration')
        .withParameter('email', email)
        .withParameter('applicationId', applicationId)
        .withMethod("PUT")
        .go<VerifyRegistrationResponse>();
  }

  /**
   * Retrieves a single action log (the log of a user action that was taken on a user previously) for the given Id.
   *
   * @param {string} actionId The Id of the action to retrieve.
   * @returns {Observable<ClientResponse<ActionResponse>>}
   */
  retrieveAction(actionId: string): Observable<ClientResponse<ActionResponse>> {
    return this.start()
        .withUri('/api/user/action')
        .withUriSegment(actionId)
        .withMethod("GET")
        .go<ActionResponse>();
  }

  /**
   * Retrieves all of the actions for the user with the given Id. This will return all time based actions that are active,
   * and inactive as well as non-time based actions.
   *
   * @param {string} userId The Id of the user to fetch the actions for.
   * @returns {Observable<ClientResponse<ActionResponse>>}
   */
  retrieveActions(userId: string): Observable<ClientResponse<ActionResponse>> {
    return this.start()
        .withUri('/api/user/action')
        .withParameter('userId', userId)
        .withMethod("GET")
        .go<ActionResponse>();
  }

  /**
   * Retrieves all of the actions for the user with the given Id that are currently preventing the User from logging in.
   *
   * @param {string} userId The Id of the user to fetch the actions for.
   * @returns {Observable<ClientResponse<ActionResponse>>}
   */
  retrieveActionsPreventingLogin(userId: string): Observable<ClientResponse<ActionResponse>> {
    return this.start()
        .withUri('/api/user/action')
        .withParameter('userId', userId)
        .withParameter('preventingLogin', true)
        .withMethod("GET")
        .go<ActionResponse>();
  }

  /**
   * Retrieves all of the actions for the user with the given Id that are currently active.
   * An active action means one that is time based and has not been canceled, and has not ended.
   *
   * @param {string} userId The Id of the user to fetch the actions for.
   * @returns {Observable<ClientResponse<ActionResponse>>}
   */
  retrieveActiveActions(userId: string): Observable<ClientResponse<ActionResponse>> {
    return this.start()
        .withUri('/api/user/action')
        .withParameter('userId', userId)
        .withParameter('active', true)
        .withMethod("GET")
        .go<ActionResponse>();
  }

  /**
   * Retrieves the application for the given id or all of the applications if the id is null.
   *
   * @param {string} applicationId (Optional) The application id.
   * @returns {Observable<ClientResponse<ApplicationResponse>>}
   */
  retrieveApplication(applicationId: string): Observable<ClientResponse<ApplicationResponse>> {
    return this.start()
        .withUri('/api/application')
        .withUriSegment(applicationId)
        .withMethod("GET")
        .go<ApplicationResponse>();
  }

  /**
   * Retrieves all of the applications.
   *
   * @returns {Observable<ClientResponse<ApplicationResponse>>}
   */
  retrieveApplications(): Observable<ClientResponse<ApplicationResponse>> {
    return this.start()
        .withUri('/api/application')
        .withMethod("GET")
        .go<ApplicationResponse>();
  }

  /**
   * Retrieves a single audit log for the given Id.
   *
   * @param {number} auditLogId The Id of the audit log to retrieve.
   * @returns {Observable<ClientResponse<AuditLogResponse>>}
   */
  retrieveAuditLog(auditLogId: number): Observable<ClientResponse<AuditLogResponse>> {
    return this.start()
        .withUri('/api/system/audit-log')
        .withUriSegment(auditLogId)
        .withMethod("GET")
        .go<AuditLogResponse>();
  }

  /**
   * Retrieves the Consent for the given Id.
   *
   * @param {string} consentId The Id of the consent.
   * @returns {Observable<ClientResponse<ConsentResponse>>}
   */
  retrieveConsent(consentId: string): Observable<ClientResponse<ConsentResponse>> {
    return this.start()
        .withUri('/api/consent')
        .withUriSegment(consentId)
        .withMethod("GET")
        .go<ConsentResponse>();
  }

  /**
   * Retrieves all of the consent.
   *
   * @returns {Observable<ClientResponse<ConsentResponse>>}
   */
  retrieveConsents(): Observable<ClientResponse<ConsentResponse>> {
    return this.start()
        .withUri('/api/consent')
        .withMethod("GET")
        .go<ConsentResponse>();
  }

  /**
   * Retrieves the daily active user report between the two instants. If you specify an application id, it will only
   * return the daily active counts for that application.
   *
   * @param {string} applicationId (Optional) The application id.
   * @param {number} start The start instant as UTC milliseconds since Epoch.
   * @param {number} end The end instant as UTC milliseconds since Epoch.
   * @returns {Observable<ClientResponse<DailyActiveUserReportResponse>>}
   */
  retrieveDailyActiveReport(applicationId: string, start: number, end: number): Observable<ClientResponse<DailyActiveUserReportResponse>> {
    return this.start()
        .withUri('/api/report/daily-active-user')
        .withParameter('applicationId', applicationId)
        .withParameter('start', start)
        .withParameter('end', end)
        .withMethod("GET")
        .go<DailyActiveUserReportResponse>();
  }

  /**
   * Retrieves the email template for the given Id. If you don't specify the id, this will return all of the email templates.
   *
   * @param {string} emailTemplateId (Optional) The Id of the email template.
   * @returns {Observable<ClientResponse<EmailTemplateResponse>>}
   */
  retrieveEmailTemplate(emailTemplateId: string): Observable<ClientResponse<EmailTemplateResponse>> {
    return this.start()
        .withUri('/api/email/template')
        .withUriSegment(emailTemplateId)
        .withMethod("GET")
        .go<EmailTemplateResponse>();
  }

  /**
   * Creates a preview of the email template provided in the request. This allows you to preview an email template that
   * hasn't been saved to the database yet. The entire email template does not need to be provided on the request. This
   * will create the preview based on whatever is given.
   *
   * @param {PreviewRequest} request The request that contains the email template and optionally a locale to render it in.
   * @returns {Observable<ClientResponse<PreviewResponse>>}
   */
  retrieveEmailTemplatePreview(request: PreviewRequest): Observable<ClientResponse<PreviewResponse>> {
    return this.start()
        .withUri('/api/email/template/preview')
        .withJSONBody(request)
        .withMethod("POST")
        .go<PreviewResponse>();
  }

  /**
   * Retrieves all of the email templates.
   *
   * @returns {Observable<ClientResponse<EmailTemplateResponse>>}
   */
  retrieveEmailTemplates(): Observable<ClientResponse<EmailTemplateResponse>> {
    return this.start()
        .withUri('/api/email/template')
        .withMethod("GET")
        .go<EmailTemplateResponse>();
  }

  /**
   * Retrieves a single event log for the given Id.
   *
   * @param {number} eventLogId The Id of the event log to retrieve.
   * @returns {Observable<ClientResponse<EventLogResponse>>}
   */
  retrieveEventLog(eventLogId: number): Observable<ClientResponse<EventLogResponse>> {
    return this.start()
        .withUri('/api/system/event-log')
        .withUriSegment(eventLogId)
        .withMethod("GET")
        .go<EventLogResponse>();
  }

  /**
   * Retrieves all of the families that a user belongs to.
   *
   * @param {string} userId The User's id
   * @returns {Observable<ClientResponse<FamilyResponse>>}
   */
  retrieveFamilies(userId: string): Observable<ClientResponse<FamilyResponse>> {
    return this.start()
        .withUri('/api/user/family')
        .withParameter('userId', userId)
        .withMethod("GET")
        .go<FamilyResponse>();
  }

  /**
   * Retrieves all of the members of a family by the unique Family Id.
   *
   * @param {string} familyId The unique Id of the Family.
   * @returns {Observable<ClientResponse<FamilyResponse>>}
   */
  retrieveFamilyMembersByFamilyId(familyId: string): Observable<ClientResponse<FamilyResponse>> {
    return this.start()
        .withUri('/api/user/family')
        .withUriSegment(familyId)
        .withMethod("GET")
        .go<FamilyResponse>();
  }

  /**
   * Retrieves the group for the given Id.
   *
   * @param {string} groupId The Id of the group.
   * @returns {Observable<ClientResponse<GroupResponse>>}
   */
  retrieveGroup(groupId: string): Observable<ClientResponse<GroupResponse>> {
    return this.start()
        .withUri('/api/group')
        .withUriSegment(groupId)
        .withMethod("GET")
        .go<GroupResponse>();
  }

  /**
   * Retrieves all of the groups.
   *
   * @returns {Observable<ClientResponse<GroupResponse>>}
   */
  retrieveGroups(): Observable<ClientResponse<GroupResponse>> {
    return this.start()
        .withUri('/api/group')
        .withMethod("GET")
        .go<GroupResponse>();
  }

  /**
   * Retrieves the identity provider for the given id or all of the identity providers if the id is null.
   *
   * @param {string} identityProviderId (Optional) The identity provider id.
   * @returns {Observable<ClientResponse<IdentityProviderResponse>>}
   */
  retrieveIdentityProvider(identityProviderId: string): Observable<ClientResponse<IdentityProviderResponse>> {
    return this.start()
        .withUri('/api/identity-provider')
        .withUriSegment(identityProviderId)
        .withMethod("GET")
        .go<IdentityProviderResponse>();
  }

  /**
   * Retrieves all of the identity providers.
   *
   * @returns {Observable<ClientResponse<IdentityProviderResponse>>}
   */
  retrieveIdentityProviders(): Observable<ClientResponse<IdentityProviderResponse>> {
    return this.start()
        .withUri('/api/identity-provider')
        .withMethod("GET")
        .go<IdentityProviderResponse>();
  }

  /**
   * Retrieves all of the actions for the user with the given Id that are currently inactive.
   * An inactive action means one that is time based and has been canceled or has expired, or is not time based.
   *
   * @param {string} userId The Id of the user to fetch the actions for.
   * @returns {Observable<ClientResponse<ActionResponse>>}
   */
  retrieveInactiveActions(userId: string): Observable<ClientResponse<ActionResponse>> {
    return this.start()
        .withUri('/api/user/action')
        .withParameter('userId', userId)
        .withParameter('active', false)
        .withMethod("GET")
        .go<ActionResponse>();
  }

  /**
   * Retrieves all of the applications that are currently inactive.
   *
   * @returns {Observable<ClientResponse<ApplicationResponse>>}
   */
  retrieveInactiveApplications(): Observable<ClientResponse<ApplicationResponse>> {
    return this.start()
        .withUri('/api/application')
        .withParameter('inactive', true)
        .withMethod("GET")
        .go<ApplicationResponse>();
  }

  /**
   * Retrieves all of the user actions that are currently inactive.
   *
   * @returns {Observable<ClientResponse<UserActionResponse>>}
   */
  retrieveInactiveUserActions(): Observable<ClientResponse<UserActionResponse>> {
    return this.start()
        .withUri('/api/user-action')
        .withParameter('inactive', true)
        .withMethod("GET")
        .go<UserActionResponse>();
  }

  /**
   * Retrieves the available integrations.
   *
   * @returns {Observable<ClientResponse<IntegrationResponse>>}
   */
  retrieveIntegration(): Observable<ClientResponse<IntegrationResponse>> {
    return this.start()
        .withUri('/api/integration')
        .withMethod("GET")
        .go<IntegrationResponse>();
  }

  /**
   * Retrieves the Public Key configured for verifying JSON Web Tokens (JWT) by the key Id. If the key Id is provided a
   * single public key will be returned if one is found by that id. If the optional parameter key Id is not provided all
   * public keys will be returned.
   *
   * @param {string} keyId (Optional) The Id of the public key.
   * @returns {Observable<ClientResponse<PublicKeyResponse>>}
   */
  retrieveJWTPublicKey(keyId: string): Observable<ClientResponse<PublicKeyResponse>> {
    return this.start()
        .withUri('/api/jwt/public-key')
        .withUriSegment(keyId)
        .withMethod("GET")
        .go<PublicKeyResponse>();
  }

  /**
   * Retrieves all Public Keys configured for verifying JSON Web Tokens (JWT).
   *
   * @returns {Observable<ClientResponse<PublicKeyResponse>>}
   */
  retrieveJWTPublicKeys(): Observable<ClientResponse<PublicKeyResponse>> {
    return this.start()
        .withUri('/api/jwt/public-key')
        .withMethod("GET")
        .go<PublicKeyResponse>();
  }

  /**
   * Retrieves the key for the given Id.
   *
   * @param {string} keyId The Id of the key.
   * @returns {Observable<ClientResponse<KeyResponse>>}
   */
  retrieveKey(keyId: string): Observable<ClientResponse<KeyResponse>> {
    return this.start()
        .withUri('/api/key')
        .withUriSegment(keyId)
        .withMethod("GET")
        .go<KeyResponse>();
  }

  /**
   * Retrieves all of the keys.
   *
   * @returns {Observable<ClientResponse<KeyResponse>>}
   */
  retrieveKeys(): Observable<ClientResponse<KeyResponse>> {
    return this.start()
        .withUri('/api/key')
        .withMethod("GET")
        .go<KeyResponse>();
  }

  /**
   * Retrieves the lambda for the given Id.
   *
   * @param {string} lambdaId The Id of the lambda.
   * @returns {Observable<ClientResponse<LambdaResponse>>}
   */
  retrieveLambda(lambdaId: string): Observable<ClientResponse<LambdaResponse>> {
    return this.start()
        .withUri('/api/lambda')
        .withUriSegment(lambdaId)
        .withMethod("GET")
        .go<LambdaResponse>();
  }

  /**
   * Retrieves all of the lambdas.
   *
   * @returns {Observable<ClientResponse<LambdaResponse>>}
   */
  retrieveLambdas(): Observable<ClientResponse<LambdaResponse>> {
    return this.start()
        .withUri('/api/lambda')
        .withMethod("GET")
        .go<LambdaResponse>();
  }

  /**
   * Retrieves all of the lambdas for the provided type.
   *
   * @param {LambdaType} type The type of the lambda to return.
   * @returns {Observable<ClientResponse<LambdaResponse>>}
   */
  retrieveLambdasByType(type: LambdaType): Observable<ClientResponse<LambdaResponse>> {
    return this.start()
        .withUri('/api/lambda')
        .withParameter('type', type)
        .withMethod("GET")
        .go<LambdaResponse>();
  }

  /**
   * Retrieves the login report between the two instants. If you specify an application id, it will only return the
   * login counts for that application.
   *
   * @param {string} applicationId (Optional) The application id.
   * @param {number} start The start instant as UTC milliseconds since Epoch.
   * @param {number} end The end instant as UTC milliseconds since Epoch.
   * @returns {Observable<ClientResponse<LoginReportResponse>>}
   */
  retrieveLoginReport(applicationId: string, start: number, end: number): Observable<ClientResponse<LoginReportResponse>> {
    return this.start()
        .withUri('/api/report/login')
        .withParameter('applicationId', applicationId)
        .withParameter('start', start)
        .withParameter('end', end)
        .withMethod("GET")
        .go<LoginReportResponse>();
  }

  /**
   * Retrieves the monthly active user report between the two instants. If you specify an application id, it will only
   * return the monthly active counts for that application.
   *
   * @param {string} applicationId (Optional) The application id.
   * @param {number} start The start instant as UTC milliseconds since Epoch.
   * @param {number} end The end instant as UTC milliseconds since Epoch.
   * @returns {Observable<ClientResponse<MonthlyActiveUserReportResponse>>}
   */
  retrieveMonthlyActiveReport(applicationId: string, start: number, end: number): Observable<ClientResponse<MonthlyActiveUserReportResponse>> {
    return this.start()
        .withUri('/api/report/monthly-active-user')
        .withParameter('applicationId', applicationId)
        .withParameter('start', start)
        .withParameter('end', end)
        .withMethod("GET")
        .go<MonthlyActiveUserReportResponse>();
  }

  /**
   * Retrieves the Oauth2 configuration for the application for the given Application Id.
   *
   * @param {string} applicationId The Id of the Application to retrieve OAuth configuration.
   * @returns {Observable<ClientResponse<OAuthConfigurationResponse>>}
   */
  retrieveOauthConfiguration(applicationId: string): Observable<ClientResponse<OAuthConfigurationResponse>> {
    return this.start()
        .withUri('/api/application')
        .withUriSegment(applicationId)
        .withUriSegment("oauth-configuration")
        .withMethod("GET")
        .go<OAuthConfigurationResponse>();
  }

  /**
   * Retrieves the password validation rules.
   *
   * @returns {Observable<ClientResponse<PasswordValidationRulesResponse>>}
   */
  retrievePasswordValidationRules(): Observable<ClientResponse<PasswordValidationRulesResponse>> {
    return this.start()
        .withUri('/api/system-configuration/password-validation-rules')
        .withMethod("GET")
        .go<PasswordValidationRulesResponse>();
  }

  /**
   * Retrieves all of the children for the given parent email address.
   *
   * @param {string} parentEmail The email of the parent.
   * @returns {Observable<ClientResponse<PendingResponse>>}
   */
  retrievePendingChildren(parentEmail: string): Observable<ClientResponse<PendingResponse>> {
    return this.start()
        .withUri('/api/user/family/pending')
        .withParameter('parentEmail', parentEmail)
        .withMethod("GET")
        .go<PendingResponse>();
  }

  /**
   * Retrieves the last number of login records.
   *
   * @param {number} offset The initial record. e.g. 0 is the last login, 100 will be the 100th most recent login.
   * @param {number} limit (Optional, defaults to 10) The number of records to retrieve.
   * @returns {Observable<ClientResponse<RecentLoginResponse>>}
   */
  retrieveRecentLogins(offset: number, limit: number): Observable<ClientResponse<RecentLoginResponse>> {
    return this.start()
        .withUri('/api/user/recent-login')
        .withParameter('offset', offset)
        .withParameter('limit', limit)
        .withMethod("GET")
        .go<RecentLoginResponse>();
  }

  /**
   * Retrieves the refresh tokens that belong to the user with the given Id.
   *
   * @param {string} userId The Id of the user.
   * @returns {Observable<ClientResponse<RefreshResponse>>}
   */
  retrieveRefreshTokens(userId: string): Observable<ClientResponse<RefreshResponse>> {
    return this.start()
        .withUri('/api/jwt/refresh')
        .withParameter('userId', userId)
        .withMethod("GET")
        .go<RefreshResponse>();
  }

  /**
   * Retrieves the user registration for the user with the given id and the given application id.
   *
   * @param {string} userId The Id of the user.
   * @param {string} applicationId The Id of the application.
   * @returns {Observable<ClientResponse<RegistrationResponse>>}
   */
  retrieveRegistration(userId: string, applicationId: string): Observable<ClientResponse<RegistrationResponse>> {
    return this.start()
        .withUri('/api/user/registration')
        .withUriSegment(userId)
        .withUriSegment(applicationId)
        .withMethod("GET")
        .go<RegistrationResponse>();
  }

  /**
   * Retrieves the registration report between the two instants. If you specify an application id, it will only return
   * the registration counts for that application.
   *
   * @param {string} applicationId (Optional) The application id.
   * @param {number} start The start instant as UTC milliseconds since Epoch.
   * @param {number} end The end instant as UTC milliseconds since Epoch.
   * @returns {Observable<ClientResponse<RegistrationReportResponse>>}
   */
  retrieveRegistrationReport(applicationId: string, start: number, end: number): Observable<ClientResponse<RegistrationReportResponse>> {
    return this.start()
        .withUri('/api/report/registration')
        .withParameter('applicationId', applicationId)
        .withParameter('start', start)
        .withParameter('end', end)
        .withMethod("GET")
        .go<RegistrationReportResponse>();
  }

  /**
   * Retrieves the system configuration.
   *
   * @returns {Observable<ClientResponse<SystemConfigurationResponse>>}
   */
  retrieveSystemConfiguration(): Observable<ClientResponse<SystemConfigurationResponse>> {
    return this.start()
        .withUri('/api/system-configuration')
        .withMethod("GET")
        .go<SystemConfigurationResponse>();
  }

  /**
   * Retrieves the tenant for the given Id.
   *
   * @param {string} tenantId The Id of the tenant.
   * @returns {Observable<ClientResponse<TenantResponse>>}
   */
  retrieveTenant(tenantId: string): Observable<ClientResponse<TenantResponse>> {
    return this.start()
        .withUri('/api/tenant')
        .withUriSegment(tenantId)
        .withMethod("GET")
        .go<TenantResponse>();
  }

  /**
   * Retrieves all of the tenants.
   *
   * @returns {Observable<ClientResponse<TenantResponse>>}
   */
  retrieveTenants(): Observable<ClientResponse<TenantResponse>> {
    return this.start()
        .withUri('/api/tenant')
        .withMethod("GET")
        .go<TenantResponse>();
  }

  /**
   * Retrieves the totals report. This contains all of the total counts for each application and the global registration
   * count.
   *
   * @returns {Observable<ClientResponse<TotalsReportResponse>>}
   */
  retrieveTotalReport(): Observable<ClientResponse<TotalsReportResponse>> {
    return this.start()
        .withUri('/api/report/totals')
        .withMethod("GET")
        .go<TotalsReportResponse>();
  }

  /**
   * Retrieves the user for the given Id.
   *
   * @param {string} userId The Id of the user.
   * @returns {Observable<ClientResponse<UserResponse>>}
   */
  retrieveUser(userId: string): Observable<ClientResponse<UserResponse>> {
    return this.start()
        .withUri('/api/user')
        .withUriSegment(userId)
        .withMethod("GET")
        .go<UserResponse>();
  }

  /**
   * Retrieves the user action for the given Id. If you pass in null for the id, this will return all of the user
   * actions.
   *
   * @param {string} userActionId (Optional) The Id of the user action.
   * @returns {Observable<ClientResponse<UserActionResponse>>}
   */
  retrieveUserAction(userActionId: string): Observable<ClientResponse<UserActionResponse>> {
    return this.start()
        .withUri('/api/user-action')
        .withUriSegment(userActionId)
        .withMethod("GET")
        .go<UserActionResponse>();
  }

  /**
   * Retrieves the user action reason for the given Id. If you pass in null for the id, this will return all of the user
   * action reasons.
   *
   * @param {string} userActionReasonId (Optional) The Id of the user action reason.
   * @returns {Observable<ClientResponse<UserActionReasonResponse>>}
   */
  retrieveUserActionReason(userActionReasonId: string): Observable<ClientResponse<UserActionReasonResponse>> {
    return this.start()
        .withUri('/api/user-action-reason')
        .withUriSegment(userActionReasonId)
        .withMethod("GET")
        .go<UserActionReasonResponse>();
  }

  /**
   * Retrieves all the user action reasons.
   *
   * @returns {Observable<ClientResponse<UserActionReasonResponse>>}
   */
  retrieveUserActionReasons(): Observable<ClientResponse<UserActionReasonResponse>> {
    return this.start()
        .withUri('/api/user-action-reason')
        .withMethod("GET")
        .go<UserActionReasonResponse>();
  }

  /**
   * Retrieves all of the user actions.
   *
   * @returns {Observable<ClientResponse<UserActionResponse>>}
   */
  retrieveUserActions(): Observable<ClientResponse<UserActionResponse>> {
    return this.start()
        .withUri('/api/user-action')
        .withMethod("GET")
        .go<UserActionResponse>();
  }

  /**
   * Retrieves the user by a change password Id. The intended use of this API is to retrieve a user after the forgot
   * password workflow has been initiated and you may not know the user's email or username.
   *
   * @param {string} changePasswordId The unique change password Id that was sent via email or returned by the Forgot Password API.
   * @returns {Observable<ClientResponse<UserResponse>>}
   */
  retrieveUserByChangePasswordId(changePasswordId: string): Observable<ClientResponse<UserResponse>> {
    return this.start()
        .withUri('/api/user')
        .withParameter('changePasswordId', changePasswordId)
        .withMethod("GET")
        .go<UserResponse>();
  }

  /**
   * Retrieves the user for the given email.
   *
   * @param {string} email The email of the user.
   * @returns {Observable<ClientResponse<UserResponse>>}
   */
  retrieveUserByEmail(email: string): Observable<ClientResponse<UserResponse>> {
    return this.start()
        .withUri('/api/user')
        .withParameter('email', email)
        .withMethod("GET")
        .go<UserResponse>();
  }

  /**
   * Retrieves the user for the loginId. The loginId can be either the username or the email.
   *
   * @param {string} loginId The email or username of the user.
   * @returns {Observable<ClientResponse<UserResponse>>}
   */
  retrieveUserByLoginId(loginId: string): Observable<ClientResponse<UserResponse>> {
    return this.start()
        .withUri('/api/user')
        .withParameter('loginId', loginId)
        .withMethod("GET")
        .go<UserResponse>();
  }

  /**
   * Retrieves the user for the given username.
   *
   * @param {string} username The username of the user.
   * @returns {Observable<ClientResponse<UserResponse>>}
   */
  retrieveUserByUsername(username: string): Observable<ClientResponse<UserResponse>> {
    return this.start()
        .withUri('/api/user')
        .withParameter('username', username)
        .withMethod("GET")
        .go<UserResponse>();
  }

  /**
   * Retrieves the user by a verificationId. The intended use of this API is to retrieve a user after the forgot
   * password workflow has been initiated and you may not know the user's email or username.
   *
   * @param {string} verificationId The unique verification Id that has been set on the user object.
   * @returns {Observable<ClientResponse<UserResponse>>}
   */
  retrieveUserByVerificationId(verificationId: string): Observable<ClientResponse<UserResponse>> {
    return this.start()
        .withUri('/api/user')
        .withParameter('verificationId', verificationId)
        .withMethod("GET")
        .go<UserResponse>();
  }

  /**
   * Retrieves all of the comments for the user with the given Id.
   *
   * @param {string} userId The Id of the user.
   * @returns {Observable<ClientResponse<UserCommentResponse>>}
   */
  retrieveUserComments(userId: string): Observable<ClientResponse<UserCommentResponse>> {
    return this.start()
        .withUri('/api/user/comment')
        .withUriSegment(userId)
        .withMethod("GET")
        .go<UserCommentResponse>();
  }

  /**
   * Retrieve a single User consent by Id.
   *
   * @param {string} userConsentId The User consent Id
   * @returns {Observable<ClientResponse<UserConsentResponse>>}
   */
  retrieveUserConsent(userConsentId: string): Observable<ClientResponse<UserConsentResponse>> {
    return this.start()
        .withUri('/api/user/consent')
        .withUriSegment(userConsentId)
        .withMethod("GET")
        .go<UserConsentResponse>();
  }

  /**
   * Retrieves all of the consents for a User.
   *
   * @param {string} userId The User's Id
   * @returns {Observable<ClientResponse<UserConsentResponse>>}
   */
  retrieveUserConsents(userId: string): Observable<ClientResponse<UserConsentResponse>> {
    return this.start()
        .withUri('/api/user/consent')
        .withParameter('userId', userId)
        .withMethod("GET")
        .go<UserConsentResponse>();
  }

  /**
   * Retrieves the login report between the two instants for a particular user by Id. If you specify an application id, it will only return the
   * login counts for that application.
   *
   * @param {string} applicationId (Optional) The application id.
   * @param {string} userId The userId id.
   * @param {number} start The start instant as UTC milliseconds since Epoch.
   * @param {number} end The end instant as UTC milliseconds since Epoch.
   * @returns {Observable<ClientResponse<LoginReportResponse>>}
   */
  retrieveUserLoginReport(applicationId: string, userId: string, start: number, end: number): Observable<ClientResponse<LoginReportResponse>> {
    return this.start()
        .withUri('/api/report/login')
        .withParameter('applicationId', applicationId)
        .withParameter('userId', userId)
        .withParameter('start', start)
        .withParameter('end', end)
        .withMethod("GET")
        .go<LoginReportResponse>();
  }

  /**
   * Retrieves the login report between the two instants for a particular user by login Id. If you specify an application id, it will only return the
   * login counts for that application.
   *
   * @param {string} applicationId (Optional) The application id.
   * @param {string} loginId The userId id.
   * @param {number} start The start instant as UTC milliseconds since Epoch.
   * @param {number} end The end instant as UTC milliseconds since Epoch.
   * @returns {Observable<ClientResponse<LoginReportResponse>>}
   */
  retrieveUserLoginReportByLoginId(applicationId: string, loginId: string, start: number, end: number): Observable<ClientResponse<LoginReportResponse>> {
    return this.start()
        .withUri('/api/report/login')
        .withParameter('applicationId', applicationId)
        .withParameter('loginId', loginId)
        .withParameter('start', start)
        .withParameter('end', end)
        .withMethod("GET")
        .go<LoginReportResponse>();
  }

  /**
   * Retrieves the last number of login records for a user.
   *
   * @param {string} userId The Id of the user.
   * @param {number} offset The initial record. e.g. 0 is the last login, 100 will be the 100th most recent login.
   * @param {number} limit (Optional, defaults to 10) The number of records to retrieve.
   * @returns {Observable<ClientResponse<RecentLoginResponse>>}
   */
  retrieveUserRecentLogins(userId: string, offset: number, limit: number): Observable<ClientResponse<RecentLoginResponse>> {
    return this.start()
        .withUri('/api/user/recent-login')
        .withParameter('userId', userId)
        .withParameter('offset', offset)
        .withParameter('limit', limit)
        .withMethod("GET")
        .go<RecentLoginResponse>();
  }

  /**
   * Retrieves the user for the given Id. This method does not use an API key, instead it uses a JSON Web Token (JWT) for authentication.
   *
   * @param {string} encodedJWT The encoded JWT (access token).
   * @returns {Observable<ClientResponse<UserResponse>>}
   */
  retrieveUserUsingJWT(encodedJWT: string): Observable<ClientResponse<UserResponse>> {
    return this.start()
        .withUri('/api/user')
        .withAuthorization('JWT ' + encodedJWT)
        .withMethod("GET")
        .go<UserResponse>();
  }

  /**
   * Retrieves the webhook for the given Id. If you pass in null for the id, this will return all the webhooks.
   *
   * @param {string} webhookId (Optional) The Id of the webhook.
   * @returns {Observable<ClientResponse<WebhookResponse>>}
   */
  retrieveWebhook(webhookId: string): Observable<ClientResponse<WebhookResponse>> {
    return this.start()
        .withUri('/api/webhook')
        .withUriSegment(webhookId)
        .withMethod("GET")
        .go<WebhookResponse>();
  }

  /**
   * Retrieves all the webhooks.
   *
   * @returns {Observable<ClientResponse<WebhookResponse>>}
   */
  retrieveWebhooks(): Observable<ClientResponse<WebhookResponse>> {
    return this.start()
        .withUri('/api/webhook')
        .withMethod("GET")
        .go<WebhookResponse>();
  }

  /**
   * Revokes a single refresh token, all tokens for a user or all tokens for an application. If you provide a user id
   * and an application id, this will delete all the refresh tokens for that user for that application.
   *
   * @param {string} token (Optional) The refresh token to delete.
   * @param {string} userId (Optional) The user id whose tokens to delete.
   * @param {string} applicationId (Optional) The application id of the tokens to delete.
   * @returns {Observable<ClientResponse<void>>}
   */
  revokeRefreshToken(token: string, userId: string, applicationId: string): Observable<ClientResponse<void>> {
    return this.start()
        .withUri('/api/jwt/refresh')
        .withParameter('token', token)
        .withParameter('userId', userId)
        .withParameter('applicationId', applicationId)
        .withMethod("DELETE")
        .go<void>();
  }

  /**
   * Revokes a single User consent by Id.
   *
   * @param {string} userConsentId The User Consent Id
   * @returns {Observable<ClientResponse<void>>}
   */
  revokeUserConsent(userConsentId: string): Observable<ClientResponse<void>> {
    return this.start()
        .withUri('/api/user/consent')
        .withUriSegment(userConsentId)
        .withMethod("DELETE")
        .go<void>();
  }

  /**
   * Searches the audit logs with the specified criteria and pagination.
   *
   * @param {AuditLogSearchRequest} request The search criteria and pagination information.
   * @returns {Observable<ClientResponse<AuditLogSearchResponse>>}
   */
  searchAuditLogs(request: AuditLogSearchRequest): Observable<ClientResponse<AuditLogSearchResponse>> {
    return this.start()
        .withUri('/api/system/audit-log/search')
        .withJSONBody(request)
        .withMethod("POST")
        .go<AuditLogSearchResponse>();
  }

  /**
   * Searches the event logs with the specified criteria and pagination.
   *
   * @param {EventLogSearchRequest} request The search criteria and pagination information.
   * @returns {Observable<ClientResponse<EventLogSearchResponse>>}
   */
  searchEventLogs(request: EventLogSearchRequest): Observable<ClientResponse<EventLogSearchResponse>> {
    return this.start()
        .withUri('/api/system/event-log/search')
        .withJSONBody(request)
        .withMethod("POST")
        .go<EventLogSearchResponse>();
  }

  /**
   * Searches the login records with the specified criteria and pagination.
   *
   * @param {LoginRecordSearchRequest} request The search criteria and pagination information.
   * @returns {Observable<ClientResponse<LoginRecordSearchResponse>>}
   */
  searchLoginRecords(request: LoginRecordSearchRequest): Observable<ClientResponse<LoginRecordSearchResponse>> {
    return this.start()
        .withUri('/api/system/login-record/search')
        .withJSONBody(request)
        .withMethod("POST")
        .go<LoginRecordSearchResponse>();
  }

  /**
   * Retrieves the users for the given ids. If any id is invalid, it is ignored.
   *
   * @param {Array<string>} ids The user ids to search for.
   * @returns {Observable<ClientResponse<SearchResponse>>}
   */
  searchUsers(ids: Array<string>): Observable<ClientResponse<SearchResponse>> {
    return this.start()
        .withUri('/api/user/search')
        .withParameter('ids', ids)
        .withMethod("GET")
        .go<SearchResponse>();
  }

  /**
   * Retrieves the users for the given search criteria and pagination.
   *
   * @param {SearchRequest} request The search criteria and pagination constraints. Fields used: queryString, numberOfResults, startRow,
   *    and sort fields.
   * @returns {Observable<ClientResponse<SearchResponse>>}
   */
  searchUsersByQueryString(request: SearchRequest): Observable<ClientResponse<SearchResponse>> {
    return this.start()
        .withUri('/api/user/search')
        .withJSONBody(request)
        .withMethod("POST")
        .go<SearchResponse>();
  }

  /**
   * Send an email using an email template id. You can optionally provide <code>requestData</code> to access key value
   * pairs in the email template.
   *
   * @param {string} emailTemplateId The id for the template.
   * @param {SendRequest} request The send email request that contains all of the information used to send the email.
   * @returns {Observable<ClientResponse<SendResponse>>}
   */
  sendEmail(emailTemplateId: string, request: SendRequest): Observable<ClientResponse<SendResponse>> {
    return this.start()
        .withUri('/api/email/send')
        .withUriSegment(emailTemplateId)
        .withJSONBody(request)
        .withMethod("POST")
        .go<SendResponse>();
  }

  /**
   * Sends out an email to a parent that they need to register and create a family or need to log in and add a child to their existing family.
   *
   * @param {FamilyEmailRequest} request The request object that contains the parent email.
   * @returns {Observable<ClientResponse<void>>}
   */
  sendFamilyRequestEmail(request: FamilyEmailRequest): Observable<ClientResponse<void>> {
    return this.start()
        .withUri('/api/user/family/request')
        .withJSONBody(request)
        .withMethod("POST")
        .go<void>();
  }

  /**
   * Send a passwordless authentication code in an email to complete login.
   *
   * @param {PasswordlessSendRequest} request The passwordless send request that contains all of the information used to send an email containing a code.
   * @returns {Observable<ClientResponse<void>>}
   */
  sendPasswordlessCode(request: PasswordlessSendRequest): Observable<ClientResponse<void>> {
    return this.start()
        .withUri('/api/passwordless/send')
        .withJSONBody(request)
        .withMethod("POST")
        .go<void>();
  }

  /**
   * Send a Two Factor authentication code to assist in setting up Two Factor authentication or disabling.
   *
   * @param {TwoFactorSendRequest} request The request object that contains all of the information used to send the code.
   * @returns {Observable<ClientResponse<void>>}
   */
  sendTwoFactorCode(request: TwoFactorSendRequest): Observable<ClientResponse<void>> {
    return this.start()
        .withUri('/api/two-factor/send')
        .withJSONBody(request)
        .withMethod("POST")
        .go<void>();
  }

  /**
   * Send a Two Factor authentication code to allow the completion of Two Factor authentication.
   *
   * @param {string} twoFactorId The Id returned by the Login API necessary to complete Two Factor authentication.
   * @returns {Observable<ClientResponse<void>>}
   */
  sendTwoFactorCodeForLogin(twoFactorId: string): Observable<ClientResponse<void>> {
    return this.start()
        .withHeader('Content-Type', 'text/plain')
        .withUri('/api/two-factor/send')
        .withUriSegment(twoFactorId)
        .withMethod("POST")
        .go<void>();
  }

  /**
   * Complete login using a 2FA challenge
   *
   * @param {TwoFactorLoginRequest} request The login request that contains the user credentials used to log them in.
   * @returns {Observable<ClientResponse<LoginResponse>>}
   */
  twoFactorLogin(request: TwoFactorLoginRequest): Observable<ClientResponse<LoginResponse>> {
    return this.start()
        .withUri('/api/two-factor/login')
        .withJSONBody(request)
        .withMethod("POST")
        .go<LoginResponse>();
  }

  /**
   * Updates the application with the given Id.
   *
   * @param {string} applicationId The Id of the application to update.
   * @param {ApplicationRequest} request The request that contains all of the new application information.
   * @returns {Observable<ClientResponse<ApplicationResponse>>}
   */
  updateApplication(applicationId: string, request: ApplicationRequest): Observable<ClientResponse<ApplicationResponse>> {
    return this.start()
        .withUri('/api/application')
        .withUriSegment(applicationId)
        .withJSONBody(request)
        .withMethod("PUT")
        .go<ApplicationResponse>();
  }

  /**
   * Updates the application role with the given id for the application.
   *
   * @param {string} applicationId The Id of the application that the role belongs to.
   * @param {string} roleId The Id of the role to update.
   * @param {ApplicationRequest} request The request that contains all of the new role information.
   * @returns {Observable<ClientResponse<ApplicationResponse>>}
   */
  updateApplicationRole(applicationId: string, roleId: string, request: ApplicationRequest): Observable<ClientResponse<ApplicationResponse>> {
    return this.start()
        .withUri('/api/application')
        .withUriSegment(applicationId)
        .withUriSegment("role")
        .withUriSegment(roleId)
        .withJSONBody(request)
        .withMethod("PUT")
        .go<ApplicationResponse>();
  }

  /**
   * Updates the consent with the given Id.
   *
   * @param {string} consentId The Id of the consent to update.
   * @param {ConsentRequest} request The request that contains all of the new consent information.
   * @returns {Observable<ClientResponse<ConsentResponse>>}
   */
  updateConsent(consentId: string, request: ConsentRequest): Observable<ClientResponse<ConsentResponse>> {
    return this.start()
        .withUri('/api/consent')
        .withUriSegment(consentId)
        .withJSONBody(request)
        .withMethod("PUT")
        .go<ConsentResponse>();
  }

  /**
   * Updates the email template with the given Id.
   *
   * @param {string} emailTemplateId The Id of the email template to update.
   * @param {EmailTemplateRequest} request The request that contains all of the new email template information.
   * @returns {Observable<ClientResponse<EmailTemplateResponse>>}
   */
  updateEmailTemplate(emailTemplateId: string, request: EmailTemplateRequest): Observable<ClientResponse<EmailTemplateResponse>> {
    return this.start()
        .withUri('/api/email/template')
        .withUriSegment(emailTemplateId)
        .withJSONBody(request)
        .withMethod("PUT")
        .go<EmailTemplateResponse>();
  }

  /**
   * Updates the group with the given Id.
   *
   * @param {string} groupId The Id of the group to update.
   * @param {GroupRequest} request The request that contains all of the new group information.
   * @returns {Observable<ClientResponse<GroupResponse>>}
   */
  updateGroup(groupId: string, request: GroupRequest): Observable<ClientResponse<GroupResponse>> {
    return this.start()
        .withUri('/api/group')
        .withUriSegment(groupId)
        .withJSONBody(request)
        .withMethod("PUT")
        .go<GroupResponse>();
  }

  /**
   * Updates the identity provider with the given Id.
   *
   * @param {string} identityProviderId The Id of the identity provider to update.
   * @param {IdentityProviderRequest} request The request object that contains the updated identity provider.
   * @returns {Observable<ClientResponse<IdentityProviderResponse>>}
   */
  updateIdentityProvider(identityProviderId: string, request: IdentityProviderRequest): Observable<ClientResponse<IdentityProviderResponse>> {
    return this.start()
        .withUri('/api/identity-provider')
        .withUriSegment(identityProviderId)
        .withJSONBody(request)
        .withMethod("PUT")
        .go<IdentityProviderResponse>();
  }

  /**
   * Updates the available integrations.
   *
   * @param {IntegrationRequest} request The request that contains all of the new integration information.
   * @returns {Observable<ClientResponse<IntegrationResponse>>}
   */
  updateIntegrations(request: IntegrationRequest): Observable<ClientResponse<IntegrationResponse>> {
    return this.start()
        .withUri('/api/integration')
        .withJSONBody(request)
        .withMethod("PUT")
        .go<IntegrationResponse>();
  }

  /**
   * Updates the key with the given Id.
   *
   * @param {string} keyId The Id of the key to update.
   * @param {KeyRequest} request The request that contains all of the new key information.
   * @returns {Observable<ClientResponse<KeyResponse>>}
   */
  updateKey(keyId: string, request: KeyRequest): Observable<ClientResponse<KeyResponse>> {
    return this.start()
        .withUri('/api/key')
        .withUriSegment(keyId)
        .withJSONBody(request)
        .withMethod("PUT")
        .go<KeyResponse>();
  }

  /**
   * Updates the lambda with the given Id.
   *
   * @param {string} lambdaId The Id of the lambda to update.
   * @param {LambdaRequest} request The request that contains all of the new lambda information.
   * @returns {Observable<ClientResponse<LambdaResponse>>}
   */
  updateLambda(lambdaId: string, request: LambdaRequest): Observable<ClientResponse<LambdaResponse>> {
    return this.start()
        .withUri('/api/lambda')
        .withUriSegment(lambdaId)
        .withJSONBody(request)
        .withMethod("PUT")
        .go<LambdaResponse>();
  }

  /**
   * Updates the registration for the user with the given id and the application defined in the request.
   *
   * @param {string} userId The Id of the user whose registration is going to be updated.
   * @param {RegistrationRequest} request The request that contains all of the new registration information.
   * @returns {Observable<ClientResponse<RegistrationResponse>>}
   */
  updateRegistration(userId: string, request: RegistrationRequest): Observable<ClientResponse<RegistrationResponse>> {
    return this.start()
        .withUri('/api/user/registration')
        .withUriSegment(userId)
        .withJSONBody(request)
        .withMethod("PUT")
        .go<RegistrationResponse>();
  }

  /**
   * Updates the system configuration.
   *
   * @param {SystemConfigurationRequest} request The request that contains all of the new system configuration information.
   * @returns {Observable<ClientResponse<SystemConfigurationResponse>>}
   */
  updateSystemConfiguration(request: SystemConfigurationRequest): Observable<ClientResponse<SystemConfigurationResponse>> {
    return this.start()
        .withUri('/api/system-configuration')
        .withJSONBody(request)
        .withMethod("PUT")
        .go<SystemConfigurationResponse>();
  }

  /**
   * Updates the tenant with the given Id.
   *
   * @param {string} tenantId The Id of the tenant to update.
   * @param {TenantRequest} request The request that contains all of the new tenant information.
   * @returns {Observable<ClientResponse<TenantResponse>>}
   */
  updateTenant(tenantId: string, request: TenantRequest): Observable<ClientResponse<TenantResponse>> {
    return this.start()
        .withUri('/api/tenant')
        .withUriSegment(tenantId)
        .withJSONBody(request)
        .withMethod("PUT")
        .go<TenantResponse>();
  }

  /**
   * Updates the user with the given Id.
   *
   * @param {string} userId The Id of the user to update.
   * @param {UserRequest} request The request that contains all of the new user information.
   * @returns {Observable<ClientResponse<UserResponse>>}
   */
  updateUser(userId: string, request: UserRequest): Observable<ClientResponse<UserResponse>> {
    return this.start()
        .withUri('/api/user')
        .withUriSegment(userId)
        .withJSONBody(request)
        .withMethod("PUT")
        .go<UserResponse>();
  }

  /**
   * Updates the user action with the given Id.
   *
   * @param {string} userActionId The Id of the user action to update.
   * @param {UserActionRequest} request The request that contains all of the new user action information.
   * @returns {Observable<ClientResponse<UserActionResponse>>}
   */
  updateUserAction(userActionId: string, request: UserActionRequest): Observable<ClientResponse<UserActionResponse>> {
    return this.start()
        .withUri('/api/user-action')
        .withUriSegment(userActionId)
        .withJSONBody(request)
        .withMethod("PUT")
        .go<UserActionResponse>();
  }

  /**
   * Updates the user action reason with the given Id.
   *
   * @param {string} userActionReasonId The Id of the user action reason to update.
   * @param {UserActionReasonRequest} request The request that contains all of the new user action reason information.
   * @returns {Observable<ClientResponse<UserActionReasonResponse>>}
   */
  updateUserActionReason(userActionReasonId: string, request: UserActionReasonRequest): Observable<ClientResponse<UserActionReasonResponse>> {
    return this.start()
        .withUri('/api/user-action-reason')
        .withUriSegment(userActionReasonId)
        .withJSONBody(request)
        .withMethod("PUT")
        .go<UserActionReasonResponse>();
  }

  /**
   * Updates a single User consent by Id.
   *
   * @param {string} userConsentId The User Consent Id
   * @param {UserConsentRequest} request The request that contains the user consent information.
   * @returns {Observable<ClientResponse<UserConsentResponse>>}
   */
  updateUserConsent(userConsentId: string, request: UserConsentRequest): Observable<ClientResponse<UserConsentResponse>> {
    return this.start()
        .withUri('/api/user/consent')
        .withUriSegment(userConsentId)
        .withJSONBody(request)
        .withMethod("PUT")
        .go<UserConsentResponse>();
  }

  /**
   * Updates the webhook with the given Id.
   *
   * @param {string} webhookId The Id of the webhook to update.
   * @param {WebhookRequest} request The request that contains all of the new webhook information.
   * @returns {Observable<ClientResponse<WebhookResponse>>}
   */
  updateWebhook(webhookId: string, request: WebhookRequest): Observable<ClientResponse<WebhookResponse>> {
    return this.start()
        .withUri('/api/webhook')
        .withUriSegment(webhookId)
        .withJSONBody(request)
        .withMethod("PUT")
        .go<WebhookResponse>();
  }

  /**
   * Validates the provided JWT (encoded JWT string) to ensure the token is valid. A valid access token is properly
   * signed and not expired.
   * <p>
   * This API may be used to verify the JWT as well as decode the encoded JWT into human readable identity claims.
   *
   * @param {string} encodedJWT The encoded JWT (access token).
   * @returns {Observable<ClientResponse<ValidateResponse>>}
   */
  validateJWT(encodedJWT: string): Observable<ClientResponse<ValidateResponse>> {
    return this.start()
        .withUri('/api/jwt/validate')
        .withAuthorization('JWT ' + encodedJWT)
        .withMethod("GET")
        .go<ValidateResponse>();
  }

  /**
   * Confirms a email verification. The Id given is usually from an email sent to the user.
   *
   * @param {string} verificationId The email verification id sent to the user.
   * @returns {Observable<ClientResponse<void>>}
   */
  verifyEmail(verificationId: string): Observable<ClientResponse<void>> {
    return this.start()
        .withHeader('Content-Type', 'text/plain')
        .withUri('/api/user/verify-email')
        .withUriSegment(verificationId)
        .withMethod("POST")
        .go<void>();
  }

  /**
   * Confirms an application registration. The Id given is usually from an email sent to the user.
   *
   * @param {string} verificationId The registration verification Id sent to the user.
   * @returns {Observable<ClientResponse<void>>}
   */
  verifyRegistration(verificationId: string): Observable<ClientResponse<void>> {
    return this.start()
        .withHeader('Content-Type', 'text/plain')
        .withUri('/api/user/verify-registration')
        .withUriSegment(verificationId)
        .withMethod("POST")
        .go<void>();
  }


  /* ===================================================================================================================
   * Private methods
   * ===================================================================================================================*/

  /**
   * creates a rest client
   *
   * @returns {IRestClient} The RESTClient that will be used to call.
   * @private
   */
  private start(): IRESTClient {
    return this.clientBuilder.build(this.host).withAuthorization(this.apiKey);
  }
}

/**
 * @author Daniel DeGroff
 */
export interface AccessToken {
  access_token?: string;
  clientId?: string;
  expires_in?: number;
  id_token?: string;
  redirectURI?: string;
  refresh_token?: string;
  scope?: string;
  token_type?: TokenType;
  userId?: string;
}

export interface ActionData {
  action?: UserAction;
  actionee?: User;
  actioneeUserId?: string;
  actioner?: User;
  actionerUserId?: string;
  applicationIds?: Array<string>;
  comment?: string;
  emailUser?: boolean;
  expiry?: number;
  log?: UserActionLog;
  notifyUser?: boolean;
  option?: string;
  reason?: UserActionReason;
  reasonId?: string;
  userActionId?: string;
}

/**
 * The user action request object.
 *
 * @author Brian Pontarelli
 */
export interface ActionRequest {
  action?: ActionData;
  broadcast?: boolean;
}

/**
 * The user action response object.
 *
 * @author Brian Pontarelli
 */
export interface ActionResponse {
  action?: UserActionLog;
  actions?: Array<UserActionLog>;
}

/**
 * Available JSON Web Algorithms (JWA) as described in RFC 7518 available for this JWT implementation.
 *
 * @author Daniel DeGroff
 */
export enum Algorithm {
  ES256,
  ES384,
  ES512,
  HS256,
  HS384,
  HS512,
  RS256,
  RS384,
  RS512,
  none
}

/**
 * @author Seth Musselman
 */
export interface Application {
  active?: boolean;
  authenticationTokenConfiguration?: AuthenticationTokenConfiguration;
  cleanSpeakConfiguration?: CleanSpeakConfiguration;
  data?: Map<string, any>;
  id?: string;
  jwtConfiguration?: JWTConfiguration;
  lambdaConfiguration?: LambdaConfiguration;
  loginConfiguration?: LoginConfiguration;
  name?: string;
  oauthConfiguration?: OAuth2Configuration;
  passwordlessConfiguration?: PasswordlessConfiguration;
  registrationConfiguration?: RegistrationConfiguration;
  roles?: Array<ApplicationRole>;
  samlv2Configuration?: SAMLv2Configuration;
  tenantId?: string;
  verificationEmailTemplateId?: string;
  verifyRegistration?: boolean;
}

/**
 * Events that are bound to applications.
 *
 * @author Brian Pontarelli
 */
export interface ApplicationEvent {
}

/**
 * The Application API request object.
 *
 * @author Brian Pontarelli
 */
export interface ApplicationRequest {
  application?: Application;
  role?: ApplicationRole;
  webhookIds?: Array<string>;
}

/**
 * The Application API response.
 *
 * @author Brian Pontarelli
 */
export interface ApplicationResponse {
  application?: Application;
  applications?: Array<Application>;
  role?: ApplicationRole;
}

/**
 * A role given to a user for a specific application.
 *
 * @author Seth Musselman
 */
export interface ApplicationRole {
  applicationId?: string;
  description?: string;
  display?: string;
  id?: string;
  isDefault?: boolean;
  isSuperRole?: boolean;
  name?: string;
}

/**
 * This class is a simple attachment with a byte array, name and MIME type.
 *
 * @author Brian Pontarelli
 */
export interface Attachment {
  attachment?: Array<number>;
  mime?: string;
  name?: string;
}

/**
 * An audit log.
 *
 * @author Brian Pontarelli
 */
export interface AuditLog {
  data?: Map<string, any>;
  id?: number;
  insertInstant?: number;
  insertUser?: string;
  message?: string;
  newValue?: any;
  oldValue?: any;
  reason?: string;
}

export interface AuditLogConfiguration {
  delete?: DeleteConfiguration;
}

/**
 * @author Daniel DeGroff
 */
export interface AuditLogExportRequest extends BaseExportRequest {
  criteria?: AuditLogSearchCriteria;
}

/**
 * @author Brian Pontarelli
 */
export interface AuditLogRequest {
  auditLog?: AuditLog;
}

/**
 * Audit log response.
 *
 * @author Brian Pontarelli
 */
export interface AuditLogResponse {
  auditLog?: AuditLog;
}

/**
 * @author Brian Pontarelli
 */
export interface AuditLogSearchCriteria extends BaseSearchCriteria {
  end?: number;
  message?: string;
  start?: number;
  user?: string;
}

/**
 * @author Brian Pontarelli
 */
export interface AuditLogSearchRequest {
  search?: AuditLogSearchCriteria;
}

/**
 * Audit log response.
 *
 * @author Brian Pontarelli
 */
export interface AuditLogSearchResponse {
  auditLogs?: Array<AuditLog>;
  total?: number;
}

export interface AuthenticationTokenConfiguration extends Enableable {
}

/**
 * Base-class for all FusionAuth events.
 *
 * @author Brian Pontarelli
 */
export interface BaseEvent {
  createInstant?: number;
  id?: string;
  type?: EventType;
}

/**
 * @author Daniel DeGroff
 */
export interface BaseExportRequest {
  dateTimeSecondsFormat?: string;
  zoneId?: string;
}

// Do not require a setter for 'type', it is defined by the concrete class and is not mutable
export interface BaseIdentityProvider<D extends BaseIdentityProviderApplicationConfiguration> extends Enableable {
  applicationConfiguration?: Map<string, D>;
  data?: Map<string, any>;
  id?: string;
  name?: string;
  type?: IdentityProviderType;
}

/**
 * @author Daniel DeGroff
 */
export interface BaseIdentityProviderApplicationConfiguration extends Enableable {
  createRegistration?: boolean;
  data?: Map<string, any>;
}

/**
 * @author Daniel DeGroff
 */
export interface BaseLoginRequest {
  applicationId?: string;
  ipAddress?: string;
  metaData?: MetaData;
  noJWT?: boolean;
}

/**
 * @author Brian Pontarelli
 */
export interface BaseSearchCriteria {
  numberOfResults?: number;
  orderBy?: string;
  startRow?: number;
}

export enum CanonicalizationMethod {
  exclusive,
  exclusive_with_comments,
  inclusive,
  inclusive_with_comments
}

export interface CertificateInformation {
  issuer?: string;
  md5Fingerprint?: string;
  serialNumber?: string;
  sha1Fingerprint?: string;
  sha1Thumbprint?: string;
  sha256Fingerprint?: string;
  sha256Thumbprint?: string;
  subject?: string;
  validFrom?: number;
  validTo?: number;
}

/**
 * Change password request object.
 *
 * @author Brian Pontarelli
 */
export interface ChangePasswordRequest {
  currentPassword?: string;
  loginId?: string;
  password?: string;
  refreshToken?: string;
}

/**
 * Change password response object.
 *
 * @author Daniel DeGroff
 */
export interface ChangePasswordResponse {
  oneTimePassword?: string;
  state?: Map<string, any>;
}

/**
 * CleanSpeak configuration at the system and application level.
 *
 * @author Brian Pontarelli
 */
export interface CleanSpeakConfiguration extends Enableable {
  apiKey?: string;
  applicationIds?: Array<string>;
  url?: string;
  usernameModeration?: UsernameModeration;
}

/**
 * Models a consent.
 *
 * @author Daniel DeGroff
 */
export interface Consent {
  consentEmailTemplateId?: string;
  countryMinimumAgeForSelfConsent?: LocalizedIntegers;
  data?: Map<string, any>;
  defaultMinimumAgeForSelfConsent?: number;
  emailPlus?: EmailPlus;
  id?: string;
  multipleValuesAllowed?: boolean;
  name?: string;
  values?: Array<string>;
}

/**
 * API request for User consent types.
 *
 * @author Daniel DeGroff
 */
export interface ConsentRequest {
  consent?: Consent;
}

/**
 * API response for consent.
 *
 * @author Daniel DeGroff
 */
export interface ConsentResponse {
  consent?: Consent;
  consents?: Array<Consent>;
}

/**
 * Models a consent.
 *
 * @author Daniel DeGroff
 */
export enum ConsentStatus {
  Active,
  Revoked
}

/**
 * Status for content like usernames, profile attributes, etc.
 *
 * @author Brian Pontarelli
 */
export enum ContentStatus {
  ACTIVE,
  PENDING,
  REJECTED
}

/**
 * @author Brian Pontarelli
 */
export interface Count {
  count?: number;
  interval?: number;
}

/**
 * Response for the daily active user report.
 *
 * @author Brian Pontarelli
 */
export interface DailyActiveUserReportResponse {
  dailyActiveUsers?: Array<Count>;
  total?: number;
}

export interface DeleteConfiguration extends Enableable {
  numberOfDaysToRetain?: number;
}

/**
 * @author Daniel DeGroff
 */
export interface DeviceInfo {
  description?: string;
  lastAccessedAddress?: string;
  lastAccessedInstant?: number;
  name?: string;
  type?: DeviceType;
}

export enum DeviceType {
  BROWSER,
  DESKTOP,
  LAPTOP,
  MOBILE,
  OTHER,
  SERVER,
  TABLET,
  TV,
  UNKNOWN
}

/**
 * A displayable raw login that includes application name and user loginId.
 *
 * @author Brian Pontarelli
 */
export interface DisplayableRawLogin extends RawLogin {
  applicationName?: string;
  loginId?: string;
}

/**
 * Interface for all identity providers that can be domain based.
 */
export interface DomainBasedIdentityProvider {
}

/**
 * This class is an abstraction of a simple email message.
 *
 * @author Brian Pontarelli
 */
export interface Email {
  attachments?: Array<Attachment>;
  bcc?: Array<EmailAddress>;
  cc?: Array<EmailAddress>;
  from?: EmailAddress;
  html?: string;
  replyTo?: EmailAddress;
  subject?: string;
  text?: string;
  to?: Array<EmailAddress>;
}

/**
 * An email address.
 *
 * @author Brian Pontarelli
 */
export interface EmailAddress {
  address?: string;
  display?: string;
}

export interface EmailConfiguration extends Enableable {
  forgotPasswordEmailTemplateId?: string;
  host?: string;
  password?: string;
  passwordlessEmailTemplateId?: string;
  port?: number;
  properties?: string;
  security?: EmailSecurityType;
  setPasswordEmailTemplateId?: string;
  username?: string;
  verificationEmailTemplateId?: string;
  verifyEmail?: boolean;
  verifyEmailWhenChanged?: boolean;
}

export interface EmailPlus extends Enableable {
  emailTemplateId?: string;
  maximumTimeToSendEmailInHours?: number;
  minimumTimeToSendEmailInHours?: number;
}

export enum EmailSecurityType {
  NONE,
  SSL,
  TLS
}

/**
 * Stores an email template used to send emails to users.
 *
 * @author Brian Pontarelli
 */
export interface EmailTemplate {
  defaultFromName?: string;
  defaultHtmlTemplate?: string;
  defaultSubject?: string;
  defaultTextTemplate?: string;
  fromEmail?: string;
  id?: string;
  localizations?: Set<string>;
  localizedFromNames?: LocalizedStrings;
  localizedHtmlTemplates?: LocalizedStrings;
  localizedSubjects?: LocalizedStrings;
  localizedTextTemplates?: LocalizedStrings;
  name?: string;
}

export interface EmailTemplateErrors {
  parseErrors?: Map<string, string>;
  renderErrors?: Map<string, string>;
}

/**
 * Email template request.
 *
 * @author Brian Pontarelli
 */
export interface EmailTemplateRequest {
  emailTemplate?: EmailTemplate;
}

/**
 * Email template response.
 *
 * @author Brian Pontarelli
 */
export interface EmailTemplateResponse {
  emailTemplate?: EmailTemplate;
  emailTemplates?: Array<EmailTemplate>;
}

/**
 * Something that can be enabled and thus also disabled.
 *
 * @author Daniel DeGroff
 */
export interface Enableable {
  enabled?: boolean;
}

/**
 * Defines an error.
 *
 * @author Brian Pontarelli
 */
export interface Error {
  code?: string;
  message?: string;
  values?: Array<any>;
}

/**
 * Standard error domain object that can also be used as the response from an API call.
 *
 * @author Brian Pontarelli
 */
export interface Errors {
  fieldErrors?: Map<string, Array<Error>>;
  generalErrors?: Array<Error>;
}

export interface EventConfiguration {
  events?: Map<EventType, EventConfigurationData>;
}

export interface EventConfigurationData extends Enableable {
  transactionType?: TransactionType;
}

/**
 * Event log used internally by FusionAuth to help developers debug hooks, Webhooks, email templates, etc.
 *
 * @author Brian Pontarelli
 */
export interface EventLog {
  id?: number;
  insertInstant?: number;
  message?: string;
  type?: EventLogType;
}

export interface EventLogConfiguration {
  numberToRetain?: number;
}

/**
 * Event log response.
 *
 * @author Daniel DeGroff
 */
export interface EventLogResponse {
  eventLog?: EventLog;
}

/**
 * Search criteria for the event log.
 *
 * @author Brian Pontarelli
 */
export interface EventLogSearchCriteria extends BaseSearchCriteria {
  end?: number;
  message?: string;
  start?: number;
  type?: EventLogType;
}

/**
 * @author Brian Pontarelli
 */
export interface EventLogSearchRequest {
  search?: EventLogSearchCriteria;
}

/**
 * Event log response.
 *
 * @author Brian Pontarelli
 */
export interface EventLogSearchResponse {
  eventLogs?: Array<EventLog>;
  total?: number;
}

/**
 * Event Log Type
 *
 * @author Daniel DeGroff
 */
export enum EventLogType {
  Information,
  Debug,
  Error
}

/**
 * Container for the event information. This is the JSON that is sent from FusionAuth to webhooks.
 *
 * @author Brian Pontarelli
 */
export interface EventRequest {
  event?: BaseEvent;
}

/**
 * Models the event types that FusionAuth produces.
 *
 * @author Brian Pontarelli
 */
export enum EventType {
  UserDelete,
  UserCreate,
  UserUpdate,
  UserDeactivate,
  UserBulkCreate,
  UserReactivate,
  UserAction,
  JWTRefreshTokenRevoke,
  JWTPublicKeyUpdate,
  UserLoginSuccess,
  UserLoginFailed,
  UserRegistrationCreate,
  UserRegistrationUpdate,
  UserRegistrationDelete,
  Test
}

/**
 * @author Brian Pontarelli
 */
export enum ExpiryUnit {
  MINUTES,
  HOURS,
  DAYS,
  WEEKS,
  MONTHS,
  YEARS
}

export interface ExternalIdentifierConfiguration {
  authorizationGrantIdTimeToLiveInSeconds?: number;
  changePasswordIdTimeToLiveInSeconds?: number;
  emailVerificationIdTimeToLiveInSeconds?: number;
  oneTimePasswordTimeToLiveInSeconds?: number;
  passwordlessLoginTimeToLiveInSeconds?: number;
  registrationVerificationIdTimeToLiveInSeconds?: number;
  setupPasswordIdTimeToLiveInSeconds?: number;
  twoFactorIdTimeToLiveInSeconds?: number;
  twoFactorTrustIdTimeToLiveInSeconds?: number;
}

/**
 * @author Daniel DeGroff
 */
export interface ExternalJWTApplicationConfiguration extends BaseIdentityProviderApplicationConfiguration {
}

/**
 * External JWT-only identity provider.
 *
 * @author Daniel DeGroff and Brian Pontarelli
 */
export interface ExternalJWTIdentityProvider extends BaseIdentityProvider<ExternalJWTApplicationConfiguration> {
  claimMap?: Map<string, string>;
  domains?: Set<string>;
  headerKeyParameter?: string;
  keys?: Map<string, string>;
  oauth2?: IdentityProviderOauth2Configuration;
  type?: IdentityProviderType;
  uniqueIdentityClaim?: string;
}

/**
 * @author Daniel DeGroff
 */
export interface FacebookApplicationConfiguration extends BaseIdentityProviderApplicationConfiguration {
  appId?: string;
  buttonText?: string;
  client_secret?: string;
  fields?: string;
  permissions?: string;
}

/**
 * Facebook social login provider.
 *
 * @author Brian Pontarelli
 */
export interface FacebookIdentityProvider extends BaseIdentityProvider<FacebookApplicationConfiguration> {
  appId?: string;
  buttonText?: string;
  client_secret?: string;
  fields?: string;
  permissions?: string;
  type?: IdentityProviderType;
}

/**
 * Configuration for the behavior of failed login attempts. This helps us protect against brute force password attacks.
 *
 * @author Daniel DeGroff
 */
export interface FailedAuthenticationConfiguration {
  actionDuration?: number;
  actionDurationUnit?: ExpiryUnit;
  resetCountInSeconds?: number;
  tooManyAttempts?: number;
  userActionId?: string;
}

/**
 * Models a family grouping of users.
 *
 * @author Brian Pontarelli
 */
export interface Family {
  id?: string;
  members?: Array<FamilyMember>;
}

export interface FamilyConfiguration extends Enableable {
  allowChildRegistrations?: boolean;
  confirmChildEmailTemplateId?: string;
  deleteOrphanedAccounts?: boolean;
  deleteOrphanedAccountsDays?: number;
  familyRequestEmailTemplateId?: string;
  maximumChildAge?: number;
  minimumOwnerAge?: number;
  parentEmailRequired?: boolean;
  parentRegistrationEmailTemplateId?: string;
}

/**
 * API request for sending out family requests to parent's.
 *
 * @author Brian Pontarelli
 */
export interface FamilyEmailRequest {
  parentEmail?: string;
}

/**
 * Models a single family member.
 *
 * @author Brian Pontarelli
 */
export interface FamilyMember {
  data?: Map<string, any>;
  insertInstant?: number;
  owner?: boolean;
  role?: FamilyRole;
  userId?: string;
}

/**
 * API request for managing families and members.
 *
 * @author Brian Pontarelli
 */
export interface FamilyRequest {
  familyMember?: FamilyMember;
}

/**
 * API response for managing families and members.
 *
 * @author Brian Pontarelli
 */
export interface FamilyResponse {
  families?: Array<Family>;
  family?: Family;
}

export enum FamilyRole {
  Child,
  Teen,
  Adult
}

/**
 * Forgot password request object.
 *
 * @author Brian Pontarelli
 */
export interface ForgotPasswordRequest {
  changePasswordId?: string;
  email?: string;
  loginId?: string;
  sendForgotPasswordEmail?: boolean;
  state?: Map<string, any>;
  username?: string;
}

/**
 * Forgot password response object.
 *
 * @author Daniel DeGroff
 */
export interface ForgotPasswordResponse {
  changePasswordId?: string;
}

/**
 * @author Daniel DeGroff
 */
export interface GoogleApplicationConfiguration extends BaseIdentityProviderApplicationConfiguration {
  buttonText?: string;
  client_id?: string;
  client_secret?: string;
  scope?: string;
}

/**
 * Google social login provider.
 *
 * @author Daniel DeGroff
 */
export interface GoogleIdentityProvider extends BaseIdentityProvider<GoogleApplicationConfiguration> {
  buttonText?: string;
  client_id?: string;
  client_secret?: string;
  scope?: string;
  type?: IdentityProviderType;
}

/**
 * Authorization Grant types as defined by the <a href="https://tools.ietf.org/html/rfc6749">The OAuth 2.0 Authorization
 * Framework - RFC 6749</a>.
 * <p>
 * Specific names as defined by <a href="https://tools.ietf.org/html/rfc7591#section-4.1">
 * OAuth 2.0 Dynamic Client Registration Protocol - RFC 7591 Section 4.1</a>
 *
 * @author Daniel DeGroff
 */
export enum GrantType {
  authorization_code,
  implicit,
  password,
  client_credentials,
  refresh_token,
  unknown
}

/**
 * @author Tyler Scott
 */
export interface Group {
  data?: Map<string, any>;
  id?: string;
  name?: string;
  roles?: Map<string, Array<ApplicationRole>>;
  tenantId?: string;
}

/**
 * A User's membership into a Group
 *
 * @author Daniel DeGroff
 */
export interface GroupMember {
  data?: Map<string, any>;
  groupId?: string;
  id?: string;
  insertInstant?: number;
  userId?: string;
}

/**
 * Group API request object.
 *
 * @author Daniel DeGroff
 */
export interface GroupRequest {
  group?: Group;
  roleIds?: Array<string>;
}

/**
 * Group API response object.
 *
 * @author Daniel DeGroff
 */
export interface GroupResponse {
  group?: Group;
  groups?: Array<Group>;
}

export interface HistoryItem {
  actionerUserId?: string;
  comment?: string;
  createInstant?: number;
  expiry?: number;
}

/**
 * Type for webhook headers.
 *
 * @author Brian Pontarelli
 */
export interface HTTPHeaders extends Map<string, string> {
}

/**
 * Login API request object used for login to third-party systems (i.e. Login with Facebook).
 *
 * @author Brian Pontarelli
 */
export interface IdentityProviderLoginRequest extends BaseLoginRequest {
  data?: Map<string, string>;
  encodedJWT?: string;
  identityProviderId?: string;
}

/**
 * @author Daniel DeGroff
 */
export interface IdentityProviderOauth2Configuration {
  authorization_endpoint?: string;
  client_id?: string;
  client_secret?: string;
  issuer?: string;
  scope?: string;
  token_endpoint?: string;
  userinfo_endpoint?: string;
}

/**
 * @author Daniel DeGroff
 */
export interface IdentityProviderRequest {
  identityProvider?: BaseIdentityProvider<any>;
}

/**
 * @author Daniel DeGroff
 */
export interface IdentityProviderResponse {
  identityProvider?: BaseIdentityProvider<any>;
  identityProviders?: Array<BaseIdentityProvider<any>>;
}

export enum IdentityProviderType {
  ExternalJWT,
  OpenIDConnect,
  Facebook,
  Google,
  Twitter,
  SAMLv2
}

/**
 * Import request.
 *
 * @author Brian Pontarelli
 */
export interface ImportRequest {
  encryptionScheme?: string;
  factor?: number;
  users?: Array<User>;
  validateDbConstraints?: boolean;
}

/**
 * The Integration Request
 *
 * @author Daniel DeGroff
 */
export interface IntegrationRequest {
  integrations?: Integrations;
}

/**
 * The Integration Response
 *
 * @author Daniel DeGroff
 */
export interface IntegrationResponse {
  integrations?: Integrations;
}

/**
 * Available Integrations
 *
 * @author Daniel DeGroff
 */
export interface Integrations {
  cleanspeak?: CleanSpeakConfiguration;
  kafka?: KafkaConfiguration;
  twilio?: TwilioConfiguration;
}

/**
 * Counts for a period.
 *
 * @author Brian Pontarelli
 */
export interface IntervalCount {
  applicationId?: string;
  count?: number;
  decrementedCount?: number;
  period?: number;
}

/**
 * A user over an period (for daily and monthly active user calculations).
 *
 * @author Brian Pontarelli
 */
export interface IntervalUser {
  applicationId?: string;
  period?: number;
  userId?: string;
}

/**
 * @author Daniel DeGroff
 */
export interface IntrospectResponse extends Map<string, any> {
}

/**
 * @author Daniel DeGroff
 */
export interface IssueResponse {
  refreshToken?: string;
  token?: string;
}

/**
 * @author Daniel DeGroff
 */
export interface JWKSResponse {
  keys?: Array<Map<string, any>>;
}

/**
 * JWT Configuration. A JWT Configuration for an Application may not be active if it is using the global configuration, the configuration
 * may be <code>enabled = false</code>.
 *
 * @author Daniel DeGroff
 */
export interface JWTConfiguration extends Enableable {
  accessTokenKeyId?: string;
  idTokenKeyId?: string;
  refreshTokenTimeToLiveInMinutes?: number;
  timeToLiveInSeconds?: number;
}

/**
 * Models the JWT public key Refresh Token Revoke Event (and can be converted to JSON). This event might be for a single
 * token, a user or an entire application.
 *
 * @author Brian Pontarelli
 */
export interface JWTPublicKeyUpdateEvent extends BaseEvent {
  applicationIds?: Set<string>;
  type?: EventType;
}

/**
 * Models the Refresh Token Revoke Event (and can be converted to JSON). This event might be for a single token, a user
 * or an entire application.
 *
 * @author Brian Pontarelli
 */
export interface JWTRefreshTokenRevokeEvent extends BaseEvent {
  applicationId?: string;
  applicationTimeToLiveInSeconds?: Map<string, number>;
  type?: EventType;
  userId?: string;
}

/**
 * @author Daniel DeGroff
 */
export interface KafkaConfiguration extends Enableable {
  defaultTopic?: string;
  producer?: Map<string, string>;
}

/**
 * Domain for a public key, key pair or an HMAC secret. This is used by KeyMaster to manage keys for JWTs, SAML, etc.
 *
 * @author Brian Pontarelli
 */
export interface Key {
  algorithm?: KeyAlgorithm;
  certificate?: string;
  certificateInformation?: CertificateInformation;
  displayName?: string;
  expirationInstant?: number;
  id?: string;
  insertInstant?: number;
  issuer?: string;
  kid?: string;
  length?: number;
  name?: string;
  pair?: boolean;
  privateKey?: string;
  publicKey?: string;
  secret?: string;
  type?: KeyType;
}

export enum KeyAlgorithm {
  ES256,
  ES384,
  ES512,
  HS256,
  HS384,
  HS512,
  RS256,
  RS384,
  RS512
}

/**
 * Key API request object.
 *
 * @author Daniel DeGroff
 */
export interface KeyRequest {
  key?: Key;
}

/**
 * Key API response object.
 *
 * @author Daniel DeGroff
 */
export interface KeyResponse {
  key?: Key;
  keys?: Array<Key>;
}

export enum KeyType {
  EC,
  RSA,
  HMAC
}

/**
 * A JavaScript lambda function that is executed during certain events inside FusionAuth.
 *
 * @author Brian Pontarelli
 */
export interface Lambda extends Enableable {
  body?: string;
  debug?: boolean;
  id?: string;
  insertInstant?: number;
  name?: string;
  type?: LambdaType;
}

export interface LambdaConfiguration {
  accessTokenPopulateId?: string;
  idTokenPopulateId?: string;
  samlv2PopulateId?: string;
}

export interface LambdaConfiguration {
  reconcileId?: string;
}

/**
 * Lambda API request object.
 *
 * @author Brian Pontarelli
 */
export interface LambdaRequest {
  lambda?: Lambda;
}

/**
 * Lambda API response object.
 *
 * @author Brian Pontarelli
 */
export interface LambdaResponse {
  lambda?: Lambda;
  lambdas?: Array<Lambda>;
}

/**
 * The types of lambdas that indicate how they are invoked by FusionAuth.
 *
 * @author Brian Pontarelli
 */
export enum LambdaType {
  JWTPopulate,
  OpenIDReconcile,
  SAMLv2Reconcile,
  SAMLv2Populate
}

/**
 * Models a set of localized Integers that can be stored as JSON.
 *
 * @author Daniel DeGroff
 */
export interface LocalizedIntegers extends Map<string, number> {
}

/**
 * Models a set of localized Strings that can be stored as JSON.
 *
 * @author Brian Pontarelli
 */
export interface LocalizedStrings extends Map<string, string> {
}

/**
 * A historical state of a user log event. Since events can be modified, this stores the historical state.
 *
 * @author Brian Pontarelli
 */
export interface LogHistory {
  historyItems?: Array<HistoryItem>;
}

export interface LoginConfiguration {
  allowTokenRefresh?: boolean;
  generateRefreshTokens?: boolean;
  requireAuthentication?: boolean;
}

export enum LoginIdType {
  email,
  username
}

/**
 * The summary of the action that is preventing login to be returned on the login response.
 *
 * @author Daniel DeGroff
 */
export interface LoginPreventedResponse {
  actionerUserId?: string;
  actionId?: string;
  expiry?: number;
  localizedName?: string;
  localizedOption?: string;
  localizedReason?: string;
  name?: string;
  option?: string;
  reason?: string;
  reasonCode?: string;
}

export interface LoginRecordConfiguration {
  delete?: DeleteConfiguration;
}

/**
 * @author Daniel DeGroff
 */
export interface LoginRecordExportRequest extends BaseExportRequest {
  criteria?: LoginRecordSearchCriteria;
}

/**
 * @author Daniel DeGroff
 */
export interface LoginRecordSearchCriteria extends BaseSearchCriteria {
  applicationId?: string;
  end?: number;
  start?: number;
  userId?: string;
}

/**
 * @author Daniel DeGroff
 */
export interface LoginRecordSearchRequest {
  retrieveTotal?: boolean;
  search?: LoginRecordSearchCriteria;
}

/**
 * A raw login record response
 *
 * @author Daniel DeGroff
 */
export interface LoginRecordSearchResponse {
  logins?: Array<DisplayableRawLogin>;
  total?: number;
}

/**
 * Response for the login report.
 *
 * @author Brian Pontarelli
 */
export interface LoginReportResponse {
  hourlyCounts?: Array<Count>;
  total?: number;
}

/**
 * Login API request object.
 *
 * @author Seth Musselman
 */
export interface LoginRequest extends BaseLoginRequest {
  loginId?: string;
  oneTimePassword?: string;
  password?: string;
  twoFactorTrustId?: string;
}

/**
 * @author Brian Pontarelli
 */
export interface LoginResponse {
  actions?: Array<LoginPreventedResponse>;
  changePasswordId?: string;
  refreshToken?: string;
  state?: Map<string, any>;
  token?: string;
  twoFactorId?: string;
  twoFactorTrustId?: string;
  user?: User;
}

export interface LoginTheme extends Enableable {
  emailComplete?: string;
  emailSend?: string;
  emailVerify?: string;
  helpers?: string;
  lastModified?: number;
  oauth2Authorize?: string;
  oauth2ChildRegistrationNotAllowed?: string;
  oauth2ChildRegistrationNotAllowedComplete?: string;
  oauth2CompleteRegistration?: string;
  oauth2Error?: string;
  oauth2Register?: string;
  oauth2TwoFactor?: string;
  passwordChange?: string;
  passwordComplete?: string;
  passwordForgot?: string;
  passwordSent?: string;
  registrationComplete?: string;
  registrationSend?: string;
  registrationVerify?: string;
  stylesheet?: string;
}

/**
 * @author Daniel DeGroff
 */
export interface LookupResponse {
  identityProvider?: BaseIdentityProvider<any>;
}

/**
 * @author Daniel DeGroff
 */
export interface MaximumPasswordAge extends Enableable {
  days?: number;
}

/**
 * Group Member Delete Request
 *
 * @author Daniel DeGroff
 */
export interface MemberDeleteRequest {
  memberIds?: Array<string>;
  members?: Map<string, Array<string>>;
}

/**
 * Group Member Request
 *
 * @author Daniel DeGroff
 */
export interface MemberRequest {
  members?: Map<string, Array<GroupMember>>;
}

/**
 * Group Member Response
 *
 * @author Daniel DeGroff
 */
export interface MemberResponse {
  members?: Map<string, Array<GroupMember>>;
}

export interface MetaData {
  device?: DeviceInfo;
  scopes?: Set<string>;
}

/**
 * @author Daniel DeGroff
 */
export interface MinimumPasswordAge extends Enableable {
  seconds?: number;
}

/**
 * Response for the daily active user report.
 *
 * @author Brian Pontarelli
 */
export interface MonthlyActiveUserReportResponse {
  monthlyActiveUsers?: Array<Count>;
  total?: number;
}

/**
 * Helper methods for normalizing values.
 *
 * @author Brian Pontarelli
 */
export interface Normalizer {
}

/**
 * @author Daniel DeGroff
 */
export interface OAuth2Configuration {
  authorizedOriginURLs?: Array<string>;
  authorizedRedirectURLs?: Array<string>;
  clientId?: string;
  clientSecret?: string;
  enabledGrants?: Set<GrantType>;
  generateRefreshTokens?: boolean;
  logoutURL?: string;
  requireClientAuthentication?: boolean;
}

/**
 * @author Daniel DeGroff
 */
export interface OAuthConfigurationResponse {
  httpSessionMaxInactiveInterval?: number;
  logoutURL?: string;
  oauthConfiguration?: OAuth2Configuration;
}

/**
 * @author Daniel DeGroff
 */
export interface OAuthError {
  change_password_id?: string;
  error?: OAuthErrorType;
  error_description?: string;
  error_reason?: OAuthErrorReason;
  error_uri?: string;
  two_factor_id?: string;
}

export enum OAuthErrorReason {
  auth_code_not_found,
  access_token_malformed,
  access_token_expired,
  access_token_unavailable_for_processing,
  access_token_failed_processing,
  refresh_token_not_found,
  invalid_client_id,
  invalid_user_credentials,
  invalid_grant_type,
  invalid_origin,
  invalid_pkce_code_verifier_length,
  invalid_pkce_code_challenge_length,
  invalid_pkce_code_challenge_method,
  invalid_redirect_uri,
  invalid_response_type,
  grant_type_disabled,
  missing_client_id,
  missing_code,
  missing_code_challenge,
  missing_grant_type,
  missing_redirect_uri,
  missing_refresh_token,
  missing_response_type,
  missing_token,
  login_prevented,
  user_expired,
  user_not_found,
  client_authentication_missing,
  invalid_client_authentication_scheme,
  invalid_client_authentication,
  client_id_mismatch,
  unknown
}

export enum OAuthErrorType {
  invalid_request,
  invalid_client,
  invalid_grant,
  invalid_token,
  unauthorized_client,
  invalid_scope,
  server_error,
  unsupported_grant_type,
  unsupported_response_type,
  change_password_required,
  two_factor_required
}

/**
 * @author Daniel DeGroff
 */
export interface OAuthResponse {
}

/**
 * OpenID Configuration as described by the <a href="https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata">OpenID
 * Provider Metadata</a>.
 *
 * @author Daniel DeGroff
 */
export interface OpenIdConfiguration {
  authorization_endpoint?: string;
  claims_supported?: Array<string>;
  grant_types_supported?: Array<string>;
  id_token_signing_alg_values_supported?: Array<string>;
  issuer?: string;
  jwks_uri?: string;
  response_types_supported?: Array<string>;
  scopes_supported?: Array<string>;
  subject_types_supported?: Array<string>;
  token_endpoint?: string;
  token_endpoint_auth_methods_supported?: Array<string>;
  userinfo_endpoint?: string;
  userinfo_signing_alg_values_supported?: Array<string>;
}

/**
 * @author Daniel DeGroff
 */
export interface OpenIdConnectApplicationConfiguration extends BaseIdentityProviderApplicationConfiguration {
  buttonImageURL?: string;
  buttonText?: string;
  oauth2?: IdentityProviderOauth2Configuration;
}

/**
 * @author Daniel DeGroff
 */
export interface OpenIdConnectIdentityProvider extends BaseIdentityProvider<OpenIdConnectApplicationConfiguration> {
  buttonImageURL?: string;
  buttonText?: string;
  domains?: Set<string>;
  lambdaConfiguration?: LambdaConfiguration;
  oauth2?: IdentityProviderOauth2Configuration;
  type?: IdentityProviderType;
}

/**
 * Password Encryption Scheme Configuration
 *
 * @author Daniel DeGroff
 */
export interface PasswordEncryptionConfiguration {
  encryptionScheme?: string;
  encryptionSchemeFactor?: number;
  modifyEncryptionSchemeOnLogin?: boolean;
}

export interface PasswordlessConfiguration extends Enableable {
}

/**
 * @author Daniel DeGroff
 */
export interface PasswordlessLoginRequest extends BaseLoginRequest {
  code?: string;
  twoFactorTrustId?: string;
}

/**
 * @author Daniel DeGroff
 */
export interface PasswordlessSendRequest {
  applicationId?: string;
  loginId?: string;
  state?: Map<string, any>;
}

/**
 * @author Derek Klatt
 */
export interface PasswordValidationRules {
  maxLength?: number;
  minLength?: number;
  rememberPreviousPasswords?: RememberPreviousPasswords;
  requireMixedCase?: boolean;
  requireNonAlpha?: boolean;
  requireNumber?: boolean;
}

/**
 * @author Daniel DeGroff
 */
export interface PasswordValidationRulesResponse {
  passwordValidationRules?: PasswordValidationRules;
}

/**
 * @author Brian Pontarelli
 */
export interface PendingResponse {
  users?: Array<User>;
}

/**
 * @author Brian Pontarelli
 */
export interface PreviewRequest {
  emailTemplate?: EmailTemplate;
  locale?: string;
}

/**
 * @author Seth Musselman
 */
export interface PreviewResponse {
  email?: Email;
  errors?: Errors;
}

/**
 * JWT Public Key Response Object
 *
 * @author Daniel DeGroff
 */
export interface PublicKeyResponse {
  publicKey?: string;
  publicKeys?: Map<string, string>;
}

/**
 * Raw login information for each time a user logs into an application.
 *
 * @author Brian Pontarelli
 */
export interface RawLogin {
  applicationId?: string;
  instant?: number;
  ipAddress?: string;
  userId?: string;
}

/**
 * Response for the user login report.
 *
 * @author Seth Musselman
 */
export interface RecentLoginResponse {
  logins?: Array<DisplayableRawLogin>;
}

/**
 * @author Daniel DeGroff
 */
export interface RefreshRequest {
  refreshToken?: string;
}

/**
 * @author Daniel DeGroff
 */
export interface RefreshResponse {
  refreshTokens?: Array<RefreshToken>;
  token?: string;
}

/**
 * Models a JWT Refresh Token.
 *
 * @author Daniel DeGroff
 */
export interface RefreshToken {
  application?: Application;
  applicationId?: string;
  insertInstant?: number;
  metaData?: MetaData;
  startInstant?: number;
  token?: string;
  userId?: string;
}

export interface RegistrationConfiguration extends Enableable {
  birthDate?: Requirable;
  confirmPassword?: boolean;
  firstName?: Requirable;
  fullName?: Requirable;
  lastName?: Requirable;
  loginIdType?: LoginIdType;
  middleName?: Requirable;
  mobilePhone?: Requirable;
}

/**
 * Response for the registration report.
 *
 * @author Brian Pontarelli
 */
export interface RegistrationReportResponse {
  hourlyCounts?: Array<Count>;
  total?: number;
}

/**
 * Registration API request object.
 *
 * @author Brian Pontarelli
 */
export interface RegistrationRequest {
  generateAuthenticationToken?: boolean;
  registration?: UserRegistration;
  sendSetPasswordEmail?: boolean;
  skipRegistrationVerification?: boolean;
  skipVerification?: boolean;
  user?: User;
}

/**
 * Registration API request object.
 *
 * @author Brian Pontarelli
 */
export interface RegistrationResponse {
  registration?: UserRegistration;
  user?: User;
}

/**
 * @author Daniel DeGroff
 */
export interface ReloadRequest {
  names?: Array<string>;
}

/**
 * @author Daniel DeGroff
 */
export interface RememberPreviousPasswords extends Enableable {
  count?: number;
}

/**
 * Something that can be required and thus also optional. This currently extends Enableable because anything that is
 * require/optional is almost always enableable as well.
 *
 * @author Brian Pontarelli
 */
export interface Requirable extends Enableable {
  required?: boolean;
}

/**
 * @author Brian Pontarelli
 */
export interface SAML2ApplicationConfiguration extends BaseIdentityProviderApplicationConfiguration {
  buttonImageURL?: string;
  buttonText?: string;
}

/**
 * SAML v2 identity provider configuration.
 *
 * @author Brian Pontarelli
 */
export interface SAML2IdentityProvider extends BaseIdentityProvider<SAML2ApplicationConfiguration> {
  buttonImageURL?: string;
  buttonText?: string;
  claimMap?: Map<string, string>;
  domains?: Set<string>;
  emailClaim?: string;
  idpEndpoint?: string;
  requestPrivateKey?: string;
  requestPublicKey?: string;
  responsePublicKey?: string;
  rolesClaim?: string;
  type?: IdentityProviderType;
}

/**
 * @author Brian Pontarelli
 */
export interface SAMLv2ApplicationConfiguration extends BaseIdentityProviderApplicationConfiguration {
  buttonImageURL?: string;
  buttonText?: string;
}

export interface SAMLv2Configuration extends Enableable {
  audience?: string;
  callbackURL?: string;
  debug?: boolean;
  issuer?: string;
  keyId?: string;
  logoutURL?: string;
  xmlSignatureC14nMethod?: CanonicalizationMethod;
}

/**
 * SAML v2 identity provider configuration.
 *
 * @author Brian Pontarelli
 */
export interface SAMLv2IdentityProvider extends BaseIdentityProvider<SAMLv2ApplicationConfiguration> {
  buttonImageURL?: string;
  buttonText?: string;
  domains?: Set<string>;
  emailClaim?: string;
  idpEndpoint?: string;
  issuer?: string;
  keyId?: string;
  lambdaConfiguration?: LambdaConfiguration;
  type?: IdentityProviderType;
  useNameIdForEmail?: boolean;
}

/**
 * Search API request.
 *
 * @author Brian Pontarelli
 */
export interface SearchRequest {
  search?: UserSearchCriteria;
}

/**
 * Search API response.
 *
 * @author Brian Pontarelli
 */
export interface SearchResponse {
  total?: number;
  users?: Array<User>;
}

/**
 * Search results.
 *
 * @author Brian Pontarelli
 */
export interface SearchResults<T> {
  results?: Array<T>;
  total?: number;
}

/**
 * @author Daniel DeGroff
 */
export interface SecretResponse {
  secret?: string;
  secretBase32Encoded?: string;
}

/**
 * @author Daniel DeGroff
 */
export interface SecureIdentity {
  encryptionScheme?: string;
  factor?: number;
  id?: string;
  password?: string;
  passwordChangeRequired?: boolean;
  passwordLastUpdateInstant?: number;
  salt?: string;
  verified?: boolean;
}

/**
 * @author Daniel DeGroff
 */
export interface SendRequest {
  bccAddresses?: Array<string>;
  ccAddresses?: Array<string>;
  requestData?: Map<string, any>;
  userIds?: Array<string>;
}

/**
 * @author Daniel DeGroff
 */
export interface SendResponse {
  results?: Map<string, EmailTemplateErrors>;
}

/**
 * @author Daniel DeGroff
 */
export enum Sort {
  asc,
  desc
}

/**
 * @author Daniel DeGroff
 */
export interface SortField {
  missing?: string;
  name?: string;
  order?: Sort;
}

/**
 * @author Brian Pontarelli
 */
export interface SystemConfiguration {
  auditLogConfiguration?: AuditLogConfiguration;
  cookieEncryptionIV?: string;
  cookieEncryptionKey?: string;
  data?: Map<string, any>;
  emailConfiguration?: EmailConfiguration;
  eventConfiguration?: EventConfiguration;
  eventLogConfiguration?: EventLogConfiguration;
  externalIdentifierConfiguration?: ExternalIdentifierConfiguration;
  failedAuthenticationConfiguration?: FailedAuthenticationConfiguration;
  httpSessionMaxInactiveInterval?: number;
  issuer?: string;
  jwtConfiguration?: JWTConfiguration;
  loginRecordConfiguration?: LoginRecordConfiguration;
  logoutURL?: string;
  maximumPasswordAge?: MaximumPasswordAge;
  minimumPasswordAge?: MinimumPasswordAge;
  passwordEncryptionConfiguration?: PasswordEncryptionConfiguration;
  passwordValidationRules?: PasswordValidationRules;
  reportTimezone?: string;
  uiConfiguration?: UIConfiguration;
}

/**
 * Request for the system configuration API.
 *
 * @author Brian Pontarelli
 */
export interface SystemConfigurationRequest {
  systemConfiguration?: SystemConfiguration;
}

/**
 * Response for the system configuration API.
 *
 * @author Brian Pontarelli
 */
export interface SystemConfigurationResponse {
  systemConfiguration?: SystemConfiguration;
}

/**
 * @author Daniel DeGroff
 */
export interface Tenant {
  data?: Map<string, any>;
  emailConfiguration?: TenantEmailConfiguration;
  familyConfiguration?: FamilyConfiguration;
  id?: string;
  name?: string;
}

export interface TenantEmailConfiguration extends Enableable {
  forgotPasswordEmailTemplateId?: string;
  passwordlessEmailTemplateId?: string;
  setPasswordEmailTemplateId?: string;
  verificationEmailTemplateId?: string;
  verifyEmail?: boolean;
  verifyEmailWhenChanged?: boolean;
}

/**
 * @author Daniel DeGroff
 */
export interface TenantRequest {
  tenant?: Tenant;
}

/**
 * @author Daniel DeGroff
 */
export interface TenantResponse {
  tenant?: Tenant;
  tenants?: Array<Tenant>;
}

/**
 * @author Daniel DeGroff
 */
export interface TestEvent extends BaseEvent {
  message?: string;
  type?: EventType;
}

/**
 * <ul>
 * <li>Bearer Token type as defined by <a href="https://tools.ietf.org/html/rfc6750">RFC 6750</a>.</li>
 * <li>MAC Token type as referenced by <a href="https://tools.ietf.org/html/rfc6749">RFC 6749</a> and
 * <a href="https://tools.ietf.org/html/draft-ietf-oauth-v2-http-mac-05">
 * Draft RFC on OAuth 2.0 Message Authentication Code (MAC) Tokens</a>
 * </li>
 * </ul>
 *
 * @author Daniel DeGroff
 */
export enum TokenType {
  Bearer,
  MAC
}

export interface Totals {
  logins?: number;
  registrations?: number;
  totalRegistrations?: number;
}

/**
 * The response from the total report. This report stores the total numbers for each application.
 *
 * @author Brian Pontarelli
 */
export interface TotalsReportResponse {
  applicationTotals?: Map<string, Totals>;
  globalRegistrations?: number;
  totalGlobalRegistrations?: number;
}

/**
 * The transaction types for Webhooks and other event systems within FusionAuth.
 *
 * @author Brian Pontarelli
 */
export enum TransactionType {
  None,
  Any,
  SimpleMajority,
  SuperMajority,
  AbsoluteMajority
}

/**
 * Twilio Service Configuration.
 *
 * @author Daniel DeGroff
 */
export interface TwilioConfiguration extends Enableable {
  accountSID?: string;
  authToken?: string;
  fromPhoneNumber?: string;
  messagingServiceSid?: string;
  url?: string;
}

/**
 * @author Daniel DeGroff
 */
export interface TwitterApplicationConfiguration extends BaseIdentityProviderApplicationConfiguration {
  buttonText?: string;
  consumerKey?: string;
  consumerSecret?: string;
}

/**
 * Twitter social login provider.
 *
 * @author Daniel DeGroff
 */
export interface TwitterIdentityProvider extends BaseIdentityProvider<TwitterApplicationConfiguration> {
  buttonText?: string;
  consumerKey?: string;
  consumerSecret?: string;
  type?: IdentityProviderType;
}

/**
 * @author Daniel DeGroff
 */
export enum TwoFactorDelivery {
  None,
  TextMessage
}

/**
 * @author Daniel DeGroff
 */
export interface TwoFactorLoginRequest extends BaseLoginRequest {
  code?: string;
  trustComputer?: boolean;
  twoFactorId?: string;
}

/**
 * @author Brian Pontarelli
 */
export interface TwoFactorRequest {
  code?: string;
  delivery?: TwoFactorDelivery;
  secret?: string;
  secretBase32Encoded?: string;
}

/**
 * @author Daniel DeGroff
 */
export interface TwoFactorSendRequest {
  mobilePhone?: string;
  secret?: string;
  userId?: string;
}

export interface UIConfiguration {
  headerColor?: string;
  loginTheme?: LoginTheme;
  logoURL?: string;
  menuFontColor?: string;
}

/**
 * The global view of a User. This object contains all global information about the user including birth date, registration information
 * preferred languages, global attributes, etc.
 *
 * @author Seth Musselman
 */
export interface User extends SecureIdentity {
  active?: boolean;
  age?: number;
  birthDate?: string;
  cleanSpeakId?: string;
  data?: Map<string, any>;
  email?: string;
  expiry?: number;
  firstName?: string;
  fullName?: string;
  imageUrl?: string;
  insertInstant?: number;
  lastLoginInstant?: number;
  lastName?: string;
  login?: string;
  memberships?: Array<GroupMember>;
  middleName?: string;
  mobilePhone?: string;
  name?: string;
  parentEmail?: string;
  preferredLanguages?: Array<string>;
  registrations?: Array<UserRegistration>;
  tenantId?: string;
  timezone?: string;
  twoFactorDelivery?: TwoFactorDelivery;
  twoFactorEnabled?: boolean;
  twoFactorSecret?: string;
  username?: string;
  usernameStatus?: ContentStatus;
}

/**
 * An action that can be executed on a user (discipline or reward potentially).
 *
 * @author Brian Pontarelli
 */
export interface UserAction {
  active?: boolean;
  cancelEmailTemplateId?: string;
  endEmailTemplateId?: string;
  id?: string;
  includeEmailInEventJSON?: boolean;
  localizedNames?: LocalizedStrings;
  modifyEmailTemplateId?: string;
  name?: string;
  options?: Array<UserActionOption>;
  preventLogin?: boolean;
  sendEndEvent?: boolean;
  startEmailTemplateId?: string;
  temporal?: boolean;
  transactionType?: TransactionType;
  userEmailingEnabled?: boolean;
  userNotificationsEnabled?: boolean;
}

/**
 * Models the user action event (and can be converted to JSON).
 *
 * @author Brian Pontarelli
 */
export interface UserActionEvent extends BaseEvent {
  action?: string;
  actioneeUserId?: string;
  actionerUserId?: string;
  actionId?: string;
  applicationIds?: Array<string>;
  comment?: string;
  email?: Email;
  emailedUser?: boolean;
  expiry?: number;
  localizedAction?: string;
  localizedDuration?: string;
  localizedOption?: string;
  localizedReason?: string;
  notifyUser?: boolean;
  option?: string;
  phase?: UserActionPhase;
  reason?: string;
  reasonCode?: string;
  type?: EventType;
}

/**
 * A log for an action that was taken on a User.
 *
 * @author Brian Pontarelli
 */
export interface UserActionLog {
  actioneeUserId?: string;
  actionerUserId?: string;
  applicationIds?: Array<string>;
  comment?: string;
  createInstant?: number;
  emailUserOnEnd?: boolean;
  endEventSent?: boolean;
  expiry?: number;
  history?: LogHistory;
  id?: string;
  localizedName?: string;
  localizedOption?: string;
  localizedReason?: string;
  name?: string;
  notifyUserOnEnd?: boolean;
  option?: string;
  reason?: string;
  reasonCode?: string;
  userActionId?: string;
}

/**
 * Models content user action options.
 *
 * @author Brian Pontarelli
 */
export interface UserActionOption {
  localizedNames?: LocalizedStrings;
  name?: string;
}

/**
 * The phases of a time-based user action.
 *
 * @author Brian Pontarelli
 */
export enum UserActionPhase {
  start,
  modify,
  cancel,
  end
}

/**
 * Models action reasons.
 *
 * @author Brian Pontarelli
 */
export interface UserActionReason {
  code?: string;
  id?: string;
  localizedTexts?: LocalizedStrings;
  text?: string;
}

/**
 * User Action Reason API request object.
 *
 * @author Brian Pontarelli
 */
export interface UserActionReasonRequest {
  userActionReason?: UserActionReason;
}

/**
 * User Action Reason API response object.
 *
 * @author Brian Pontarelli
 */
export interface UserActionReasonResponse {
  userActionReason?: UserActionReason;
  userActionReasons?: Array<UserActionReason>;
}

/**
 * User Action API request object.
 *
 * @author Brian Pontarelli
 */
export interface UserActionRequest {
  userAction?: UserAction;
}

/**
 * User Action API response object.
 *
 * @author Brian Pontarelli
 */
export interface UserActionResponse {
  userAction?: UserAction;
  userActions?: Array<UserAction>;
}

/**
 * Models the User Bulk Create Event (and can be converted to JSON).
 *
 * @author Brian Pontarelli
 */
export interface UserBulkCreateEvent extends BaseEvent {
  type?: EventType;
  users?: Array<User>;
}

/**
 * A log for an event that happened to a User.
 *
 * @author Brian Pontarelli
 */
export interface UserComment {
  comment?: string;
  commenterId?: string;
  createInstant?: number;
  id?: string;
  userId?: string;
}

/**
 * @author Seth Musselman
 */
export interface UserCommentRequest {
  userComment?: UserComment;
}

/**
 * User Comment Response
 *
 * @author Seth Musselman
 */
export interface UserCommentResponse {
  userComment?: UserComment;
  userComments?: Array<UserComment>;
}

/**
 * Models a User consent.
 *
 * @author Daniel DeGroff
 */
export interface UserConsent {
  consent?: Consent;
  consentId?: string;
  data?: Map<string, any>;
  giverUserId?: string;
  id?: string;
  insertInstant?: number;
  lastUpdateInstant?: number;
  status?: ConsentStatus;
  userId?: string;
  values?: Array<string>;
}

/**
 * API response for User consent.
 *
 * @author Daniel DeGroff
 */
export interface UserConsentRequest {
  userConsent?: UserConsent;
}

/**
 * API response for User consent.
 *
 * @author Daniel DeGroff
 */
export interface UserConsentResponse {
  userConsent?: UserConsent;
  userConsents?: Array<UserConsent>;
}

/**
 * Models the User Create Event (and can be converted to JSON).
 *
 * @author Brian Pontarelli
 */
export interface UserCreateEvent extends BaseEvent {
  type?: EventType;
  user?: User;
}

/**
 * Models the User Deactivate Event (and can be converted to JSON).
 *
 * @author Brian Pontarelli
 */
export interface UserDeactivateEvent extends BaseEvent {
  type?: EventType;
  user?: User;
}

/**
 * Models the User Event (and can be converted to JSON) that is used for all user modifications (create, update,
 * delete).
 *
 * @author Brian Pontarelli
 */
export interface UserDeleteEvent extends BaseEvent {
  type?: EventType;
  user?: User;
}

/**
 * User API delete request object.
 *
 * @author Daniel DeGroff
 */
export interface UserDeleteRequest {
  hardDelete?: boolean;
  userIds?: Array<string>;
}

/**
 * @author Daniel DeGroff
 */
export interface UserinfoResponse extends Map<string, any> {
}

/**
 * Models the User Login Failed Event.
 *
 * @author Daniel DeGroff
 */
export interface UserLoginFailedEvent extends BaseEvent {
  applicationId?: string;
  authenticationType?: string;
  type?: EventType;
  user?: User;
}

/**
 * Models the User Login Success Event.
 *
 * @author Daniel DeGroff
 */
export interface UserLoginSuccessEvent extends BaseEvent {
  applicationId?: string;
  authenticationType?: string;
  identityProviderId?: string;
  identityProviderName?: string;
  type?: EventType;
  user?: User;
}

export interface UsernameModeration extends Enableable {
  applicationId?: string;
}

/**
 * Models the User Reactivate Event (and can be converted to JSON).
 *
 * @author Brian Pontarelli
 */
export interface UserReactivateEvent extends BaseEvent {
  type?: EventType;
  user?: User;
}

/**
 * User registration information for a single application.
 *
 * @author Brian Pontarelli
 */
export interface UserRegistration {
  application?: Application;
  applicationId?: string;
  authenticationToken?: string;
  cleanSpeakId?: string;
  data?: Map<string, any>;
  id?: string;
  insertInstant?: number;
  lastLoginInstant?: number;
  preferredLanguages?: Array<string>;
  roles?: Set<string>;
  timezone?: string;
  tokens?: Map<string, string>;
  userId?: string;
  username?: string;
  usernameStatus?: ContentStatus;
  verified?: boolean;
}

/**
 * Models the User Create Registration Event (and can be converted to JSON).
 *
 * @author Daniel DeGroff
 */
export interface UserRegistrationCreateEvent extends BaseEvent {
  applicationId?: string;
  registration?: UserRegistration;
  type?: EventType;
  user?: User;
}

/**
 * Models the User Delete Registration Event (and can be converted to JSON).
 *
 * @author Daniel DeGroff
 */
export interface UserRegistrationDeleteEvent extends BaseEvent {
  applicationId?: string;
  registration?: UserRegistration;
  type?: EventType;
  user?: User;
}

/**
 * Models the User Update Registration Event (and can be converted to JSON).
 *
 * @author Daniel DeGroff
 */
export interface UserRegistrationUpdateEvent extends BaseEvent {
  applicationId?: string;
  original?: UserRegistration;
  registration?: UserRegistration;
  type?: EventType;
  user?: User;
}

/**
 * User API request object.
 *
 * @author Brian Pontarelli
 */
export interface UserRequest {
  sendSetPasswordEmail?: boolean;
  skipVerification?: boolean;
  user?: User;
}

/**
 * User API response object.
 *
 * @author Brian Pontarelli
 */
export interface UserResponse {
  user?: User;
}

/**
 * This class is the user query. It provides a build pattern as well as public fields for use on forms and in actions.
 *
 * @author Brian Pontarelli
 */
export interface UserSearchCriteria extends BaseSearchCriteria {
  email?: string;
  fullName?: string;
  id?: string;
  ids?: Array<string>;
  queryString?: string;
  sortFields?: Array<SortField>;
  username?: string;
}

/**
 * @author Daniel DeGroff
 */
export enum UserState {
  Authenticated,
  AuthenticatedNotRegistered
}

/**
 * Models the User Update Event (and can be converted to JSON).
 *
 * @author Brian Pontarelli
 */
export interface UserUpdateEvent extends BaseEvent {
  original?: User;
  type?: EventType;
  user?: User;
}

/**
 * @author Daniel DeGroff
 */
export interface ValidateResponse {
  jwt?: Map<string, any>;
}

/**
 * @author Daniel DeGroff
 */
export interface VerifyEmailResponse {
  verificationId?: string;
}

/**
 * @author Daniel DeGroff
 */
export interface VerifyRegistrationResponse {
  verificationId?: string;
}

/**
 * A server where events are sent. This includes user action events and any other events sent by FusionAuth.
 *
 * @author Brian Pontarelli
 */
export interface Webhook {
  applicationIds?: Array<string>;
  connectTimeout?: number;
  data?: WebhookData;
  description?: string;
  global?: boolean;
  headers?: HTTPHeaders;
  httpAuthenticationPassword?: string;
  httpAuthenticationUsername?: string;
  id?: string;
  readTimeout?: number;
  sslCertificate?: string;
  url?: string;
}

export interface WebhookData {
  eventsEnabled?: Map<EventType, boolean>;
}

/**
 * Webhook API request object.
 *
 * @author Brian Pontarelli
 */
export interface WebhookRequest {
  webhook?: Webhook;
}

/**
 * Webhook API response object.
 *
 * @author Brian Pontarelli
 */
export interface WebhookResponse {
  webhook?: Webhook;
  webhooks?: Array<Webhook>;
}

